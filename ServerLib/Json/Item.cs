// <auto-generated />
//
//    var itemBase = ItemBase.FromJson(jsonString);
//
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

namespace ServerLib.Json
{
    public partial class ItemBase
    {
        [JsonProperty("_id")]
        public string Id { get; set; }

        [JsonProperty("_name")]
        public string Name { get; set; }

        [JsonProperty("_parent")]
        public string Parent { get; set; }

        [JsonProperty("_type")]
        public TypeEnum Type { get; set; }

        [JsonProperty("_props")]
        public ItemBaseProps Props { get; set; }

        [JsonProperty("_proto", NullValueHandling = NullValueHandling.Ignore)]
        public string Proto { get; set; }
    }

    public partial class ItemBaseProps
    {
        [JsonProperty("Name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        [JsonProperty("ShortName", NullValueHandling = NullValueHandling.Ignore)]
        public string ShortName { get; set; }

        [JsonProperty("Description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        [JsonProperty("Weight", NullValueHandling = NullValueHandling.Ignore)]
        public double? Weight { get; set; }

        [JsonProperty("BackgroundColor", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundColor? BackgroundColor { get; set; }

        [JsonProperty("Width", NullValueHandling = NullValueHandling.Ignore)]
        public long? Width { get; set; }

        [JsonProperty("Height", NullValueHandling = NullValueHandling.Ignore)]
        public long? Height { get; set; }

        [JsonProperty("StackMaxSize", NullValueHandling = NullValueHandling.Ignore)]
        public long? StackMaxSize { get; set; }

        [JsonProperty("ItemSound", NullValueHandling = NullValueHandling.Ignore)]
        public ItemSound? ItemSound { get; set; }

        [JsonProperty("Prefab", NullValueHandling = NullValueHandling.Ignore)]
        public Prefab Prefab { get; set; }

        [JsonProperty("UsePrefab", NullValueHandling = NullValueHandling.Ignore)]
        public Prefab UsePrefab { get; set; }

        [JsonProperty("StackObjectsCount", NullValueHandling = NullValueHandling.Ignore)]
        public long? StackObjectsCount { get; set; }

        [JsonProperty("NotShownInSlot", NullValueHandling = NullValueHandling.Ignore)]
        public bool? NotShownInSlot { get; set; }

        [JsonProperty("ExaminedByDefault", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ExaminedByDefault { get; set; }

        [JsonProperty("ExamineTime", NullValueHandling = NullValueHandling.Ignore)]
        public long? ExamineTime { get; set; }

        [JsonProperty("IsUndiscardable", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsUndiscardable { get; set; }

        [JsonProperty("IsUnsaleable", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsUnsaleable { get; set; }

        [JsonProperty("IsUnbuyable", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsUnbuyable { get; set; }

        [JsonProperty("IsUngivable", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsUngivable { get; set; }

        [JsonProperty("IsLockedafterEquip", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsLockedafterEquip { get; set; }

        [JsonProperty("QuestItem", NullValueHandling = NullValueHandling.Ignore)]
        public bool? QuestItem { get; set; }

        [JsonProperty("LootExperience", NullValueHandling = NullValueHandling.Ignore)]
        public long? LootExperience { get; set; }

        [JsonProperty("ExamineExperience", NullValueHandling = NullValueHandling.Ignore)]
        public long? ExamineExperience { get; set; }

        [JsonProperty("HideEntrails", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HideEntrails { get; set; }

        [JsonProperty("RepairCost", NullValueHandling = NullValueHandling.Ignore)]
        public long? RepairCost { get; set; }

        [JsonProperty("RepairSpeed", NullValueHandling = NullValueHandling.Ignore)]
        public long? RepairSpeed { get; set; }

        [JsonProperty("ExtraSizeLeft", NullValueHandling = NullValueHandling.Ignore)]
        public long? ExtraSizeLeft { get; set; }

        [JsonProperty("ExtraSizeRight", NullValueHandling = NullValueHandling.Ignore)]
        public long? ExtraSizeRight { get; set; }

        [JsonProperty("ExtraSizeUp", NullValueHandling = NullValueHandling.Ignore)]
        public long? ExtraSizeUp { get; set; }

        [JsonProperty("ExtraSizeDown", NullValueHandling = NullValueHandling.Ignore)]
        public long? ExtraSizeDown { get; set; }

        [JsonProperty("ExtraSizeForceAdd", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ExtraSizeForceAdd { get; set; }

        [JsonProperty("MergesWithChildren", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MergesWithChildren { get; set; }

        [JsonProperty("CanSellOnRagfair", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanSellOnRagfair { get; set; }

        [JsonProperty("CanRequireOnRagfair", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanRequireOnRagfair { get; set; }

        [JsonProperty("ConflictingItems", NullValueHandling = NullValueHandling.Ignore)]
        public string[] ConflictingItems { get; set; }

        [JsonProperty("Unlootable", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Unlootable { get; set; }

        [JsonProperty("UnlootableFromSlot", NullValueHandling = NullValueHandling.Ignore)]
        public UnlootableFromSlot? UnlootableFromSlot { get; set; }

        [JsonProperty("UnlootableFromSide", NullValueHandling = NullValueHandling.Ignore)]
        public UnlootableFromSide[] UnlootableFromSide { get; set; }

        [JsonProperty("AnimationVariantsNumber", NullValueHandling = NullValueHandling.Ignore)]
        public long? AnimationVariantsNumber { get; set; }

        [JsonProperty("DiscardingBlock", NullValueHandling = NullValueHandling.Ignore)]
        public bool? DiscardingBlock { get; set; }

        [JsonProperty("RagFairCommissionModifier", NullValueHandling = NullValueHandling.Ignore)]
        public long? RagFairCommissionModifier { get; set; }

        [JsonProperty("IsAlwaysAvailableForInsurance", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsAlwaysAvailableForInsurance { get; set; }

        [JsonProperty("DiscardLimit", NullValueHandling = NullValueHandling.Ignore)]
        public long? DiscardLimit { get; set; }

        [JsonProperty("DropSoundType", NullValueHandling = NullValueHandling.Ignore)]
        public DropSoundType? DropSoundType { get; set; }

        [JsonProperty("MaxResource", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxResource { get; set; }

        [JsonProperty("Resource", NullValueHandling = NullValueHandling.Ignore)]
        public long? Resource { get; set; }

        [JsonProperty("DogTagQualities", NullValueHandling = NullValueHandling.Ignore)]
        public bool? DogTagQualities { get; set; }

        [JsonProperty("Grids", NullValueHandling = NullValueHandling.Ignore)]
        public Grid[] Grids { get; set; }

        [JsonProperty("Slots", NullValueHandling = NullValueHandling.Ignore)]
        public Slot[] Slots { get; set; }

        [JsonProperty("CanPutIntoDuringTheRaid", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanPutIntoDuringTheRaid { get; set; }

        [JsonProperty("CantRemoveFromSlotsDuringRaid", NullValueHandling = NullValueHandling.Ignore)]
        public string[] CantRemoveFromSlotsDuringRaid { get; set; }

        [JsonProperty("BlocksEarpiece", NullValueHandling = NullValueHandling.Ignore)]
        public bool? BlocksEarpiece { get; set; }

        [JsonProperty("BlocksEyewear", NullValueHandling = NullValueHandling.Ignore)]
        public bool? BlocksEyewear { get; set; }

        [JsonProperty("BlocksHeadwear", NullValueHandling = NullValueHandling.Ignore)]
        public bool? BlocksHeadwear { get; set; }

        [JsonProperty("BlocksFaceCover", NullValueHandling = NullValueHandling.Ignore)]
        public bool? BlocksFaceCover { get; set; }

        [JsonProperty("Durability", NullValueHandling = NullValueHandling.Ignore)]
        public long? Durability { get; set; }

        [JsonProperty("MaxDurability", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxDurability { get; set; }

        [JsonProperty("armorClass", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(DecodingChoiceConverter))]
        public long? ArmorClass { get; set; }

        [JsonProperty("speedPenaltyPercent", NullValueHandling = NullValueHandling.Ignore)]
        public long? SpeedPenaltyPercent { get; set; }

        [JsonProperty("mousePenalty", NullValueHandling = NullValueHandling.Ignore)]
        public long? MousePenalty { get; set; }

        [JsonProperty("weaponErgonomicPenalty", NullValueHandling = NullValueHandling.Ignore)]
        public long? WeaponErgonomicPenalty { get; set; }

        [JsonProperty("armorZone", NullValueHandling = NullValueHandling.Ignore)]
        public ArmorZone[] ArmorZone { get; set; }

        [JsonProperty("Indestructibility", NullValueHandling = NullValueHandling.Ignore)]
        public double? Indestructibility { get; set; }

        [JsonProperty("headSegments", NullValueHandling = NullValueHandling.Ignore)]
        public HeadSegment[] HeadSegments { get; set; }

        [JsonProperty("FaceShieldComponent", NullValueHandling = NullValueHandling.Ignore)]
        public bool? FaceShieldComponent { get; set; }

        [JsonProperty("FaceShieldMask", NullValueHandling = NullValueHandling.Ignore)]
        public FaceShieldMask? FaceShieldMask { get; set; }

        [JsonProperty("HasHinge", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HasHinge { get; set; }

        [JsonProperty("MaterialType", NullValueHandling = NullValueHandling.Ignore)]
        public MaterialType? MaterialType { get; set; }

        [JsonProperty("RicochetParams", NullValueHandling = NullValueHandling.Ignore)]
        public AppliedHeadRotation RicochetParams { get; set; }

        [JsonProperty("DeafStrength", NullValueHandling = NullValueHandling.Ignore)]
        public DeafStrength? DeafStrength { get; set; }

        [JsonProperty("BluntThroughput", NullValueHandling = NullValueHandling.Ignore)]
        public double? BluntThroughput { get; set; }

        [JsonProperty("ArmorMaterial", NullValueHandling = NullValueHandling.Ignore)]
        public ArmorMaterial? ArmorMaterial { get; set; }

        [JsonProperty("BlindnessProtection", NullValueHandling = NullValueHandling.Ignore)]
        public double? BlindnessProtection { get; set; }

        [JsonProperty("Distortion", NullValueHandling = NullValueHandling.Ignore)]
        public double? Distortion { get; set; }

        [JsonProperty("CompressorTreshold", NullValueHandling = NullValueHandling.Ignore)]
        public long? CompressorTreshold { get; set; }

        [JsonProperty("CompressorAttack", NullValueHandling = NullValueHandling.Ignore)]
        public long? CompressorAttack { get; set; }

        [JsonProperty("CompressorRelease", NullValueHandling = NullValueHandling.Ignore)]
        public long? CompressorRelease { get; set; }

        [JsonProperty("CompressorGain", NullValueHandling = NullValueHandling.Ignore)]
        public long? CompressorGain { get; set; }

        [JsonProperty("CutoffFreq", NullValueHandling = NullValueHandling.Ignore)]
        public long? CutoffFreq { get; set; }

        [JsonProperty("Resonance", NullValueHandling = NullValueHandling.Ignore)]
        public double? Resonance { get; set; }

        [JsonProperty("CompressorVolume", NullValueHandling = NullValueHandling.Ignore)]
        public long? CompressorVolume { get; set; }

        [JsonProperty("AmbientVolume", NullValueHandling = NullValueHandling.Ignore)]
        public long? AmbientVolume { get; set; }

        [JsonProperty("DryVolume", NullValueHandling = NullValueHandling.Ignore)]
        public long? DryVolume { get; set; }

        [JsonProperty("KeyIds", NullValueHandling = NullValueHandling.Ignore)]
        public string[] KeyIds { get; set; }

        [JsonProperty("TagColor", NullValueHandling = NullValueHandling.Ignore)]
        public long? TagColor { get; set; }

        [JsonProperty("TagName", NullValueHandling = NullValueHandling.Ignore)]
        public string TagName { get; set; }

        [JsonProperty("Accuracy", NullValueHandling = NullValueHandling.Ignore)]
        public long? Accuracy { get; set; }

        [JsonProperty("Recoil", NullValueHandling = NullValueHandling.Ignore)]
        public double? Recoil { get; set; }

        [JsonProperty("Loudness", NullValueHandling = NullValueHandling.Ignore)]
        public long? Loudness { get; set; }

        [JsonProperty("EffectiveDistance", NullValueHandling = NullValueHandling.Ignore)]
        public long? EffectiveDistance { get; set; }

        [JsonProperty("Ergonomics", NullValueHandling = NullValueHandling.Ignore)]
        public double? Ergonomics { get; set; }

        [JsonProperty("Velocity", NullValueHandling = NullValueHandling.Ignore)]
        public double? Velocity { get; set; }

        [JsonProperty("RaidModdable", NullValueHandling = NullValueHandling.Ignore)]
        public bool? RaidModdable { get; set; }

        [JsonProperty("ToolModdable", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ToolModdable { get; set; }

        [JsonProperty("BlocksFolding", NullValueHandling = NullValueHandling.Ignore)]
        public bool? BlocksFolding { get; set; }

        [JsonProperty("BlocksCollapsible", NullValueHandling = NullValueHandling.Ignore)]
        public bool? BlocksCollapsible { get; set; }

        [JsonProperty("IsAnimated", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsAnimated { get; set; }

        [JsonProperty("HasShoulderContact", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HasShoulderContact { get; set; }

        [JsonProperty("SightingRange", NullValueHandling = NullValueHandling.Ignore)]
        public long? SightingRange { get; set; }

        [JsonProperty("DoubleActionAccuracyPenaltyMult", NullValueHandling = NullValueHandling.Ignore)]
        public double? DoubleActionAccuracyPenaltyMult { get; set; }

        [JsonProperty("ShiftsAimCamera", NullValueHandling = NullValueHandling.Ignore)]
        public double? ShiftsAimCamera { get; set; }

        [JsonProperty("DurabilityBurnModificator", NullValueHandling = NullValueHandling.Ignore)]
        public double? DurabilityBurnModificator { get; set; }

        [JsonProperty("HeatFactor", NullValueHandling = NullValueHandling.Ignore)]
        public double? HeatFactor { get; set; }

        [JsonProperty("CoolFactor", NullValueHandling = NullValueHandling.Ignore)]
        public double? CoolFactor { get; set; }

        [JsonProperty("ModesCount", NullValueHandling = NullValueHandling.Ignore)]
        public ModesCount? ModesCount { get; set; }

        [JsonProperty("muzzleModType", NullValueHandling = NullValueHandling.Ignore)]
        public MuzzleModType? MuzzleModType { get; set; }

        [JsonProperty("CustomAimPlane", NullValueHandling = NullValueHandling.Ignore)]
        public CustomAimPlane? CustomAimPlane { get; set; }

        [JsonProperty("sightModType", NullValueHandling = NullValueHandling.Ignore)]
        public SightModType? SightModType { get; set; }

        [JsonProperty("ScopesCount", NullValueHandling = NullValueHandling.Ignore)]
        public long? ScopesCount { get; set; }

        [JsonProperty("AimSensitivity", NullValueHandling = NullValueHandling.Ignore)]
        public AimSensitivity? AimSensitivity { get; set; }

        [JsonProperty("Zooms", NullValueHandling = NullValueHandling.Ignore)]
        public double[][] Zooms { get; set; }

        [JsonProperty("CalibrationDistances", NullValueHandling = NullValueHandling.Ignore)]
        public long[][] CalibrationDistances { get; set; }

        [JsonProperty("Intensity", NullValueHandling = NullValueHandling.Ignore)]
        public double? Intensity { get; set; }

        [JsonProperty("Mask", NullValueHandling = NullValueHandling.Ignore)]
        public string Mask { get; set; }

        [JsonProperty("MaskSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaskSize { get; set; }

        [JsonProperty("NoiseIntensity", NullValueHandling = NullValueHandling.Ignore)]
        public double? NoiseIntensity { get; set; }

        [JsonProperty("NoiseScale", NullValueHandling = NullValueHandling.Ignore)]
        public long? NoiseScale { get; set; }

        [JsonProperty("Color", NullValueHandling = NullValueHandling.Ignore)]
        public Color Color { get; set; }

        [JsonProperty("DiffuseIntensity", NullValueHandling = NullValueHandling.Ignore)]
        public double? DiffuseIntensity { get; set; }

        [JsonProperty("RampPalette", NullValueHandling = NullValueHandling.Ignore)]
        public string RampPalette { get; set; }

        [JsonProperty("DepthFade", NullValueHandling = NullValueHandling.Ignore)]
        public double? DepthFade { get; set; }

        [JsonProperty("RoughnessCoef", NullValueHandling = NullValueHandling.Ignore)]
        public double? RoughnessCoef { get; set; }

        [JsonProperty("SpecularCoef", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpecularCoef { get; set; }

        [JsonProperty("MainTexColorCoef", NullValueHandling = NullValueHandling.Ignore)]
        public double? MainTexColorCoef { get; set; }

        [JsonProperty("MinimumTemperatureValue", NullValueHandling = NullValueHandling.Ignore)]
        public double? MinimumTemperatureValue { get; set; }

        [JsonProperty("RampShift", NullValueHandling = NullValueHandling.Ignore)]
        public double? RampShift { get; set; }

        [JsonProperty("HeatMin", NullValueHandling = NullValueHandling.Ignore)]
        public double? HeatMin { get; set; }

        [JsonProperty("ColdMax", NullValueHandling = NullValueHandling.Ignore)]
        public double? ColdMax { get; set; }

        [JsonProperty("IsNoisy", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsNoisy { get; set; }

        [JsonProperty("IsFpsStuck", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsFpsStuck { get; set; }

        [JsonProperty("IsGlitch", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsGlitch { get; set; }

        [JsonProperty("IsMotionBlurred", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsMotionBlurred { get; set; }

        [JsonProperty("IsPixelated", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsPixelated { get; set; }

        [JsonProperty("PixelationBlockCount", NullValueHandling = NullValueHandling.Ignore)]
        public long? PixelationBlockCount { get; set; }

        [JsonProperty("magAnimationIndex", NullValueHandling = NullValueHandling.Ignore)]
        public long? MagAnimationIndex { get; set; }

        [JsonProperty("Cartridges", NullValueHandling = NullValueHandling.Ignore)]
        public Cartridge[] Cartridges { get; set; }

        [JsonProperty("CanFast", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanFast { get; set; }

        [JsonProperty("CanHit", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanHit { get; set; }

        [JsonProperty("CanAdmin", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanAdmin { get; set; }

        [JsonProperty("LoadUnloadModifier", NullValueHandling = NullValueHandling.Ignore)]
        public long? LoadUnloadModifier { get; set; }

        [JsonProperty("CheckTimeModifier", NullValueHandling = NullValueHandling.Ignore)]
        public long? CheckTimeModifier { get; set; }

        [JsonProperty("CheckOverride", NullValueHandling = NullValueHandling.Ignore)]
        public long? CheckOverride { get; set; }

        [JsonProperty("ReloadMagType", NullValueHandling = NullValueHandling.Ignore)]
        public ReloadM? ReloadMagType { get; set; }

        [JsonProperty("VisibleAmmoRangesString", NullValueHandling = NullValueHandling.Ignore)]
        public VisibleAmmoRangesString? VisibleAmmoRangesString { get; set; }

        [JsonProperty("MalfunctionChance", NullValueHandling = NullValueHandling.Ignore)]
        public double? MalfunctionChance { get; set; }

        [JsonProperty("IsShoulderContact", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsShoulderContact { get; set; }

        [JsonProperty("Foldable", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Foldable { get; set; }

        [JsonProperty("Retractable", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Retractable { get; set; }

        [JsonProperty("SizeReduceRight", NullValueHandling = NullValueHandling.Ignore)]
        public long? SizeReduceRight { get; set; }

        [JsonProperty("CenterOfImpact", NullValueHandling = NullValueHandling.Ignore)]
        public double? CenterOfImpact { get; set; }

        [JsonProperty("ShotgunDispersion", NullValueHandling = NullValueHandling.Ignore)]
        public double? ShotgunDispersion { get; set; }

        [JsonProperty("IsSilencer", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsSilencer { get; set; }

        [JsonProperty("DeviationCurve", NullValueHandling = NullValueHandling.Ignore)]
        public double? DeviationCurve { get; set; }

        [JsonProperty("DeviationMax", NullValueHandling = NullValueHandling.Ignore)]
        public double? DeviationMax { get; set; }

        [JsonProperty("SearchSound", NullValueHandling = NullValueHandling.Ignore)]
        public SearchSound? SearchSound { get; set; }

        [JsonProperty("BlocksArmorVest", NullValueHandling = NullValueHandling.Ignore)]
        public bool? BlocksArmorVest { get; set; }

        [JsonProperty("GridLayoutName", NullValueHandling = NullValueHandling.Ignore)]
        public GridLayoutName? GridLayoutName { get; set; }

        [JsonProperty("SpawnFilter", NullValueHandling = NullValueHandling.Ignore)]
        public object[] SpawnFilter { get; set; }

        [JsonProperty("containType", NullValueHandling = NullValueHandling.Ignore)]
        public object[] ContainType { get; set; }

        [JsonProperty("sizeWidth", NullValueHandling = NullValueHandling.Ignore)]
        public long? SizeWidth { get; set; }

        [JsonProperty("sizeHeight", NullValueHandling = NullValueHandling.Ignore)]
        public long? SizeHeight { get; set; }

        [JsonProperty("isSecured", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsSecured { get; set; }

        [JsonProperty("spawnTypes", NullValueHandling = NullValueHandling.Ignore)]
        public string SpawnTypes { get; set; }

        [JsonProperty("lootFilter", NullValueHandling = NullValueHandling.Ignore)]
        public object[] LootFilter { get; set; }

        [JsonProperty("spawnRarity", NullValueHandling = NullValueHandling.Ignore)]
        public string SpawnRarity { get; set; }

        [JsonProperty("minCountSpawn", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinCountSpawn { get; set; }

        [JsonProperty("maxCountSpawn", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxCountSpawn { get; set; }

        [JsonProperty("openedByKeyID", NullValueHandling = NullValueHandling.Ignore)]
        public object[] OpenedByKeyId { get; set; }

        [JsonProperty("RigLayoutName", NullValueHandling = NullValueHandling.Ignore)]
        public string RigLayoutName { get; set; }

        [JsonProperty("weapClass", NullValueHandling = NullValueHandling.Ignore)]
        public WeapClass? WeapClass { get; set; }

        [JsonProperty("weapUseType", NullValueHandling = NullValueHandling.Ignore)]
        public WeapUseType? WeapUseType { get; set; }

        [JsonProperty("ammoCaliber", NullValueHandling = NullValueHandling.Ignore)]
        public string AmmoCaliber { get; set; }

        [JsonProperty("OperatingResource", NullValueHandling = NullValueHandling.Ignore)]
        public long? OperatingResource { get; set; }

        [JsonProperty("RepairComplexity", NullValueHandling = NullValueHandling.Ignore)]
        public long? RepairComplexity { get; set; }

        [JsonProperty("durabSpawnMin", NullValueHandling = NullValueHandling.Ignore)]
        public long? DurabSpawnMin { get; set; }

        [JsonProperty("durabSpawnMax", NullValueHandling = NullValueHandling.Ignore)]
        public long? DurabSpawnMax { get; set; }

        [JsonProperty("isFastReload", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsFastReload { get; set; }

        [JsonProperty("RecoilForceUp", NullValueHandling = NullValueHandling.Ignore)]
        public long? RecoilForceUp { get; set; }

        [JsonProperty("RecoilForceBack", NullValueHandling = NullValueHandling.Ignore)]
        public long? RecoilForceBack { get; set; }

        [JsonProperty("Convergence", NullValueHandling = NullValueHandling.Ignore)]
        public double? Convergence { get; set; }

        [JsonProperty("RecoilAngle", NullValueHandling = NullValueHandling.Ignore)]
        public long? RecoilAngle { get; set; }

        [JsonProperty("weapFireType", NullValueHandling = NullValueHandling.Ignore)]
        public WeapFireType[] WeapFireType { get; set; }

        [JsonProperty("RecolDispersion", NullValueHandling = NullValueHandling.Ignore)]
        public long? RecolDispersion { get; set; }

        [JsonProperty("SingleFireRate", NullValueHandling = NullValueHandling.Ignore)]
        public long? SingleFireRate { get; set; }

        [JsonProperty("CanQueueSecondShot", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanQueueSecondShot { get; set; }

        [JsonProperty("bFirerate", NullValueHandling = NullValueHandling.Ignore)]
        public long? BFirerate { get; set; }

        [JsonProperty("bEffDist", NullValueHandling = NullValueHandling.Ignore)]
        public long? BEffDist { get; set; }

        [JsonProperty("bHearDist", NullValueHandling = NullValueHandling.Ignore)]
        public long? BHearDist { get; set; }

        [JsonProperty("isChamberLoad", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsChamberLoad { get; set; }

        [JsonProperty("chamberAmmoCount", NullValueHandling = NullValueHandling.Ignore)]
        public long? ChamberAmmoCount { get; set; }

        [JsonProperty("isBoltCatch", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsBoltCatch { get; set; }

        [JsonProperty("defMagType", NullValueHandling = NullValueHandling.Ignore)]
        public string DefMagType { get; set; }

        [JsonProperty("defAmmo", NullValueHandling = NullValueHandling.Ignore)]
        public string DefAmmo { get; set; }

        [JsonProperty("AdjustCollimatorsToTrajectory", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AdjustCollimatorsToTrajectory { get; set; }

        [JsonProperty("shotgunDispersion", NullValueHandling = NullValueHandling.Ignore)]
        public long? PropsShotgunDispersion { get; set; }

        [JsonProperty("Chambers", NullValueHandling = NullValueHandling.Ignore)]
        public Chamber[] Chambers { get; set; }

        [JsonProperty("CameraRecoil", NullValueHandling = NullValueHandling.Ignore)]
        public double? CameraRecoil { get; set; }

        [JsonProperty("CameraSnap", NullValueHandling = NullValueHandling.Ignore)]
        public double? CameraSnap { get; set; }

        [JsonProperty("ReloadMode", NullValueHandling = NullValueHandling.Ignore)]
        public ReloadM? ReloadMode { get; set; }

        [JsonProperty("AimPlane", NullValueHandling = NullValueHandling.Ignore)]
        public double? AimPlane { get; set; }

        [JsonProperty("TacticalReloadStiffnes", NullValueHandling = NullValueHandling.Ignore)]
        public AppliedHeadRotation TacticalReloadStiffnes { get; set; }

        [JsonProperty("TacticalReloadFixation", NullValueHandling = NullValueHandling.Ignore)]
        public double? TacticalReloadFixation { get; set; }

        [JsonProperty("RecoilCenter", NullValueHandling = NullValueHandling.Ignore)]
        public AppliedHeadRotation RecoilCenter { get; set; }

        [JsonProperty("RotationCenter", NullValueHandling = NullValueHandling.Ignore)]
        public AppliedHeadRotation RotationCenter { get; set; }

        [JsonProperty("RotationCenterNoStock", NullValueHandling = NullValueHandling.Ignore)]
        public AppliedHeadRotation RotationCenterNoStock { get; set; }

        [JsonProperty("FoldedSlot", NullValueHandling = NullValueHandling.Ignore)]
        public FoldedSlot? FoldedSlot { get; set; }

        [JsonProperty("CompactHandling", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CompactHandling { get; set; }

        [JsonProperty("MinRepairDegradation", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinRepairDegradation { get; set; }

        [JsonProperty("MaxRepairDegradation", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxRepairDegradation { get; set; }

        [JsonProperty("IronSightRange", NullValueHandling = NullValueHandling.Ignore)]
        public long? IronSightRange { get; set; }

        [JsonProperty("MustBoltBeOpennedForExternalReload", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MustBoltBeOpennedForExternalReload { get; set; }

        [JsonProperty("MustBoltBeOpennedForInternalReload", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MustBoltBeOpennedForInternalReload { get; set; }

        [JsonProperty("BoltAction", NullValueHandling = NullValueHandling.Ignore)]
        public bool? BoltAction { get; set; }

        [JsonProperty("HipAccuracyRestorationDelay", NullValueHandling = NullValueHandling.Ignore)]
        public double? HipAccuracyRestorationDelay { get; set; }

        [JsonProperty("HipAccuracyRestorationSpeed", NullValueHandling = NullValueHandling.Ignore)]
        public long? HipAccuracyRestorationSpeed { get; set; }

        [JsonProperty("HipInnaccuracyGain", NullValueHandling = NullValueHandling.Ignore)]
        public double? HipInnaccuracyGain { get; set; }

        [JsonProperty("ManualBoltCatch", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ManualBoltCatch { get; set; }

        [JsonProperty("BurstShotsCount", NullValueHandling = NullValueHandling.Ignore)]
        public long? BurstShotsCount { get; set; }

        [JsonProperty("BaseMalfunctionChance", NullValueHandling = NullValueHandling.Ignore)]
        public double? BaseMalfunctionChance { get; set; }

        [JsonProperty("AllowJam", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AllowJam { get; set; }

        [JsonProperty("AllowFeed", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AllowFeed { get; set; }

        [JsonProperty("AllowMisfire", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AllowMisfire { get; set; }

        [JsonProperty("AllowSlide", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AllowSlide { get; set; }

        [JsonProperty("DurabilityBurnRatio", NullValueHandling = NullValueHandling.Ignore)]
        public double? DurabilityBurnRatio { get; set; }

        [JsonProperty("HeatFactorGun", NullValueHandling = NullValueHandling.Ignore)]
        public double? HeatFactorGun { get; set; }

        [JsonProperty("CoolFactorGun", NullValueHandling = NullValueHandling.Ignore)]
        public double? CoolFactorGun { get; set; }

        [JsonProperty("CoolFactorGunMods", NullValueHandling = NullValueHandling.Ignore)]
        public double? CoolFactorGunMods { get; set; }

        [JsonProperty("HeatFactorByShot", NullValueHandling = NullValueHandling.Ignore)]
        public double? HeatFactorByShot { get; set; }

        [JsonProperty("AllowOverheat", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AllowOverheat { get; set; }

        [JsonProperty("DoubleActionAccuracyPenalty", NullValueHandling = NullValueHandling.Ignore)]
        public double? DoubleActionAccuracyPenalty { get; set; }

        [JsonProperty("RecoilPosZMult", NullValueHandling = NullValueHandling.Ignore)]
        public double? RecoilPosZMult { get; set; }

        [JsonProperty("MinRepairKitDegradation", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinRepairKitDegradation { get; set; }

        [JsonProperty("MaxRepairKitDegradation", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxRepairKitDegradation { get; set; }

        [JsonProperty("IsFlareGun", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsFlareGun { get; set; }

        [JsonProperty("IsOneoff", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsOneoff { get; set; }

        [JsonProperty("IsGrenadeLauncher", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsGrenadeLauncher { get; set; }

        [JsonProperty("foodUseTime", NullValueHandling = NullValueHandling.Ignore)]
        public long? FoodUseTime { get; set; }

        [JsonProperty("foodEffectType", NullValueHandling = NullValueHandling.Ignore)]
        public DEffectType? FoodEffectType { get; set; }

        [JsonProperty("StimulatorBuffs", NullValueHandling = NullValueHandling.Ignore)]
        public string StimulatorBuffs { get; set; }

        [JsonProperty("effects_health", NullValueHandling = NullValueHandling.Ignore)]
        public EffectsHealthUnion? EffectsHealth { get; set; }

        [JsonProperty("effects_damage", NullValueHandling = NullValueHandling.Ignore)]
        public EffectsDamageUnion? EffectsDamage { get; set; }

        [JsonProperty("MaximumNumberOfUsage", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaximumNumberOfUsage { get; set; }

        [JsonProperty("knifeHitDelay", NullValueHandling = NullValueHandling.Ignore)]
        public long? KnifeHitDelay { get; set; }

        [JsonProperty("knifeHitSlashRate", NullValueHandling = NullValueHandling.Ignore)]
        public long? KnifeHitSlashRate { get; set; }

        [JsonProperty("knifeHitStabRate", NullValueHandling = NullValueHandling.Ignore)]
        public long? KnifeHitStabRate { get; set; }

        [JsonProperty("knifeHitRadius", NullValueHandling = NullValueHandling.Ignore)]
        public double? KnifeHitRadius { get; set; }

        [JsonProperty("knifeHitSlashDam", NullValueHandling = NullValueHandling.Ignore)]
        public long? KnifeHitSlashDam { get; set; }

        [JsonProperty("knifeHitStabDam", NullValueHandling = NullValueHandling.Ignore)]
        public long? KnifeHitStabDam { get; set; }

        [JsonProperty("knifeDurab", NullValueHandling = NullValueHandling.Ignore)]
        public long? KnifeDurab { get; set; }

        [JsonProperty("PrimaryDistance", NullValueHandling = NullValueHandling.Ignore)]
        public double? PrimaryDistance { get; set; }

        [JsonProperty("SecondryDistance", NullValueHandling = NullValueHandling.Ignore)]
        public double? SecondryDistance { get; set; }

        [JsonProperty("SlashPenetration", NullValueHandling = NullValueHandling.Ignore)]
        public long? SlashPenetration { get; set; }

        [JsonProperty("StabPenetration", NullValueHandling = NullValueHandling.Ignore)]
        public long? StabPenetration { get; set; }

        [JsonProperty("PrimaryConsumption", NullValueHandling = NullValueHandling.Ignore)]
        public long? PrimaryConsumption { get; set; }

        [JsonProperty("SecondryConsumption", NullValueHandling = NullValueHandling.Ignore)]
        public long? SecondryConsumption { get; set; }

        [JsonProperty("DeflectionConsumption", NullValueHandling = NullValueHandling.Ignore)]
        public long? DeflectionConsumption { get; set; }

        [JsonProperty("AppliedTrunkRotation", NullValueHandling = NullValueHandling.Ignore)]
        public AppliedHeadRotation AppliedTrunkRotation { get; set; }

        [JsonProperty("AppliedHeadRotation", NullValueHandling = NullValueHandling.Ignore)]
        public AppliedHeadRotation AppliedHeadRotation { get; set; }

        [JsonProperty("DisplayOnModel", NullValueHandling = NullValueHandling.Ignore)]
        public bool? DisplayOnModel { get; set; }

        [JsonProperty("AdditionalAnimationLayer", NullValueHandling = NullValueHandling.Ignore)]
        public long? AdditionalAnimationLayer { get; set; }

        [JsonProperty("StaminaBurnRate", NullValueHandling = NullValueHandling.Ignore)]
        public long? StaminaBurnRate { get; set; }

        [JsonProperty("ColliderScaleMultiplier", NullValueHandling = NullValueHandling.Ignore)]
        public AppliedHeadRotation ColliderScaleMultiplier { get; set; }

        [JsonProperty("ConfigPathStr", NullValueHandling = NullValueHandling.Ignore)]
        public string ConfigPathStr { get; set; }

        [JsonProperty("MaxMarkersCount", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxMarkersCount { get; set; }

        [JsonProperty("scaleMin", NullValueHandling = NullValueHandling.Ignore)]
        public double? ScaleMin { get; set; }

        [JsonProperty("scaleMax", NullValueHandling = NullValueHandling.Ignore)]
        public double? ScaleMax { get; set; }

        [JsonProperty("medUseTime", NullValueHandling = NullValueHandling.Ignore)]
        public long? MedUseTime { get; set; }

        [JsonProperty("medEffectType", NullValueHandling = NullValueHandling.Ignore)]
        public DEffectType? MedEffectType { get; set; }

        [JsonProperty("MaxHpResource", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxHpResource { get; set; }

        [JsonProperty("hpResourceRate", NullValueHandling = NullValueHandling.Ignore)]
        public long? HpResourceRate { get; set; }

        [JsonProperty("apResource", NullValueHandling = NullValueHandling.Ignore)]
        public long? ApResource { get; set; }

        [JsonProperty("krResource", NullValueHandling = NullValueHandling.Ignore)]
        public long? KrResource { get; set; }

        [JsonProperty("MaxOpticZoom", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxOpticZoom { get; set; }

        [JsonProperty("MaxRepairResource", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxRepairResource { get; set; }

        [JsonProperty("TargetItemFilter", NullValueHandling = NullValueHandling.Ignore)]
        public string[] TargetItemFilter { get; set; }

        [JsonProperty("RepairQuality", NullValueHandling = NullValueHandling.Ignore)]
        public long? RepairQuality { get; set; }

        [JsonProperty("RepairType", NullValueHandling = NullValueHandling.Ignore)]
        public string RepairType { get; set; }

        [JsonProperty("StackMinRandom", NullValueHandling = NullValueHandling.Ignore)]
        public long? StackMinRandom { get; set; }

        [JsonProperty("StackMaxRandom", NullValueHandling = NullValueHandling.Ignore)]
        public long? StackMaxRandom { get; set; }

        [JsonProperty("ammoType", NullValueHandling = NullValueHandling.Ignore)]
        public AmmoType? AmmoType { get; set; }

        [JsonProperty("InitialSpeed", NullValueHandling = NullValueHandling.Ignore)]
        public long? InitialSpeed { get; set; }

        [JsonProperty("BallisticCoeficient", NullValueHandling = NullValueHandling.Ignore)]
        public double? BallisticCoeficient { get; set; }

        [JsonProperty("BulletMassGram", NullValueHandling = NullValueHandling.Ignore)]
        public double? BulletMassGram { get; set; }

        [JsonProperty("BulletDiameterMilimeters", NullValueHandling = NullValueHandling.Ignore)]
        public double? BulletDiameterMilimeters { get; set; }

        [JsonProperty("Damage", NullValueHandling = NullValueHandling.Ignore)]
        public long? Damage { get; set; }

        [JsonProperty("ammoAccr", NullValueHandling = NullValueHandling.Ignore)]
        public long? AmmoAccr { get; set; }

        [JsonProperty("ammoRec", NullValueHandling = NullValueHandling.Ignore)]
        public long? AmmoRec { get; set; }

        [JsonProperty("ammoDist", NullValueHandling = NullValueHandling.Ignore)]
        public long? AmmoDist { get; set; }

        [JsonProperty("buckshotBullets", NullValueHandling = NullValueHandling.Ignore)]
        public long? BuckshotBullets { get; set; }

        [JsonProperty("PenetrationPower", NullValueHandling = NullValueHandling.Ignore)]
        public long? PenetrationPower { get; set; }

        [JsonProperty("PenetrationPowerDiviation", NullValueHandling = NullValueHandling.Ignore)]
        public double? PenetrationPowerDiviation { get; set; }

        [JsonProperty("ammoHear", NullValueHandling = NullValueHandling.Ignore)]
        public long? AmmoHear { get; set; }

        [JsonProperty("ammoSfx", NullValueHandling = NullValueHandling.Ignore)]
        public AmmoSfx? AmmoSfx { get; set; }

        [JsonProperty("MisfireChance", NullValueHandling = NullValueHandling.Ignore)]
        public double? MisfireChance { get; set; }

        [JsonProperty("MinFragmentsCount", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinFragmentsCount { get; set; }

        [JsonProperty("MaxFragmentsCount", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxFragmentsCount { get; set; }

        [JsonProperty("ammoShiftChance", NullValueHandling = NullValueHandling.Ignore)]
        public long? AmmoShiftChance { get; set; }

        [JsonProperty("casingName", NullValueHandling = NullValueHandling.Ignore)]
        public string CasingName { get; set; }

        [JsonProperty("casingEjectPower", NullValueHandling = NullValueHandling.Ignore)]
        public long? CasingEjectPower { get; set; }

        [JsonProperty("casingMass", NullValueHandling = NullValueHandling.Ignore)]
        public double? CasingMass { get; set; }

        [JsonProperty("casingSounds", NullValueHandling = NullValueHandling.Ignore)]
        public CasingSounds? CasingSounds { get; set; }

        [JsonProperty("ProjectileCount", NullValueHandling = NullValueHandling.Ignore)]
        public long? ProjectileCount { get; set; }

        [JsonProperty("PenetrationChance", NullValueHandling = NullValueHandling.Ignore)]
        public double? PenetrationChance { get; set; }

        [JsonProperty("RicochetChance", NullValueHandling = NullValueHandling.Ignore)]
        public double? RicochetChance { get; set; }

        [JsonProperty("FragmentationChance", NullValueHandling = NullValueHandling.Ignore)]
        public double? FragmentationChance { get; set; }

        [JsonProperty("Deterioration", NullValueHandling = NullValueHandling.Ignore)]
        public long? Deterioration { get; set; }

        [JsonProperty("SpeedRetardation", NullValueHandling = NullValueHandling.Ignore)]
        public double? SpeedRetardation { get; set; }

        [JsonProperty("Tracer", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Tracer { get; set; }

        [JsonProperty("TracerColor", NullValueHandling = NullValueHandling.Ignore)]
        public TracerColor? TracerColor { get; set; }

        [JsonProperty("TracerDistance", NullValueHandling = NullValueHandling.Ignore)]
        public double? TracerDistance { get; set; }

        [JsonProperty("ArmorDamage", NullValueHandling = NullValueHandling.Ignore)]
        public long? ArmorDamage { get; set; }

        [JsonProperty("Caliber", NullValueHandling = NullValueHandling.Ignore)]
        public string Caliber { get; set; }

        [JsonProperty("StaminaBurnPerDamage", NullValueHandling = NullValueHandling.Ignore)]
        public double? StaminaBurnPerDamage { get; set; }

        [JsonProperty("HeavyBleedingDelta", NullValueHandling = NullValueHandling.Ignore)]
        public double? HeavyBleedingDelta { get; set; }

        [JsonProperty("LightBleedingDelta", NullValueHandling = NullValueHandling.Ignore)]
        public double? LightBleedingDelta { get; set; }

        [JsonProperty("ShowBullet", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ShowBullet { get; set; }

        [JsonProperty("HasGrenaderComponent", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HasGrenaderComponent { get; set; }

        [JsonProperty("FuzeArmTimeSec", NullValueHandling = NullValueHandling.Ignore)]
        public double? FuzeArmTimeSec { get; set; }

        [JsonProperty("ExplosionStrength", NullValueHandling = NullValueHandling.Ignore)]
        public long? ExplosionStrength { get; set; }

        [JsonProperty("MinExplosionDistance", NullValueHandling = NullValueHandling.Ignore)]
        public double? MinExplosionDistance { get; set; }

        [JsonProperty("MaxExplosionDistance", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxExplosionDistance { get; set; }

        [JsonProperty("FragmentsCount", NullValueHandling = NullValueHandling.Ignore)]
        public long? FragmentsCount { get; set; }

        [JsonProperty("FragmentType", NullValueHandling = NullValueHandling.Ignore)]
        public FragmentType? FragmentType { get; set; }

        [JsonProperty("ShowHitEffectOnExplode", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ShowHitEffectOnExplode { get; set; }

        [JsonProperty("ExplosionType", NullValueHandling = NullValueHandling.Ignore)]
        public ExplosionType? ExplosionType { get; set; }

        [JsonProperty("AmmoLifeTimeSec", NullValueHandling = NullValueHandling.Ignore)]
        public long? AmmoLifeTimeSec { get; set; }

        [JsonProperty("Contusion", NullValueHandling = NullValueHandling.Ignore)]
        public AppliedHeadRotation Contusion { get; set; }

        [JsonProperty("ArmorDistanceDistanceDamage", NullValueHandling = NullValueHandling.Ignore)]
        public AppliedHeadRotation ArmorDistanceDistanceDamage { get; set; }

        [JsonProperty("Blindness", NullValueHandling = NullValueHandling.Ignore)]
        public AppliedHeadRotation Blindness { get; set; }

        [JsonProperty("IsLightAndSoundShot", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsLightAndSoundShot { get; set; }

        [JsonProperty("LightAndSoundShotAngle", NullValueHandling = NullValueHandling.Ignore)]
        public long? LightAndSoundShotAngle { get; set; }

        [JsonProperty("LightAndSoundShotSelfContusionTime", NullValueHandling = NullValueHandling.Ignore)]
        public long? LightAndSoundShotSelfContusionTime { get; set; }

        [JsonProperty("LightAndSoundShotSelfContusionStrength", NullValueHandling = NullValueHandling.Ignore)]
        public double? LightAndSoundShotSelfContusionStrength { get; set; }

        [JsonProperty("MalfMisfireChance", NullValueHandling = NullValueHandling.Ignore)]
        public double? MalfMisfireChance { get; set; }

        [JsonProperty("MalfFeedChance", NullValueHandling = NullValueHandling.Ignore)]
        public double? MalfFeedChance { get; set; }

        [JsonProperty("StackSlots", NullValueHandling = NullValueHandling.Ignore)]
        public Cartridge[] StackSlots { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public string Type { get; set; }

        [JsonProperty("eqMin", NullValueHandling = NullValueHandling.Ignore)]
        public long? EqMin { get; set; }

        [JsonProperty("eqMax", NullValueHandling = NullValueHandling.Ignore)]
        public long? EqMax { get; set; }

        [JsonProperty("rate", NullValueHandling = NullValueHandling.Ignore)]
        public long? Rate { get; set; }

        [JsonProperty("ThrowType", NullValueHandling = NullValueHandling.Ignore)]
        public ThrowType? ThrowType { get; set; }

        [JsonProperty("ExplDelay", NullValueHandling = NullValueHandling.Ignore)]
        public double? ExplDelay { get; set; }

        [JsonProperty("Strength", NullValueHandling = NullValueHandling.Ignore)]
        public long? Strength { get; set; }

        [JsonProperty("ContusionDistance", NullValueHandling = NullValueHandling.Ignore)]
        public long? ContusionDistance { get; set; }

        [JsonProperty("throwDamMax", NullValueHandling = NullValueHandling.Ignore)]
        public long? ThrowDamMax { get; set; }

        [JsonProperty("explDelay", NullValueHandling = NullValueHandling.Ignore)]
        public double? PropsExplDelay { get; set; }

        [JsonProperty("EmitTime", NullValueHandling = NullValueHandling.Ignore)]
        public long? EmitTime { get; set; }

        [JsonProperty("CanBeHiddenDuringThrow", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanBeHiddenDuringThrow { get; set; }

        [JsonProperty("MinTimeToContactExplode", NullValueHandling = NullValueHandling.Ignore)]
        public double? MinTimeToContactExplode { get; set; }

        [JsonProperty("ExplosionEffectType", NullValueHandling = NullValueHandling.Ignore)]
        public string ExplosionEffectType { get; set; }
    }

    public partial class AppliedHeadRotation
    {
        [JsonProperty("x")]
        public double X { get; set; }

        [JsonProperty("y")]
        public double Y { get; set; }

        [JsonProperty("z")]
        public double Z { get; set; }
    }

    public partial class Cartridge
    {
        [JsonProperty("_name")]
        public CartridgeName Name { get; set; }

        [JsonProperty("_id")]
        public string Id { get; set; }

        [JsonProperty("_parent")]
        public string Parent { get; set; }

        [JsonProperty("_max_count")]
        public long MaxCount { get; set; }

        [JsonProperty("_props")]
        public CartridgeProps Props { get; set; }

        [JsonProperty("_proto")]
        public CartridgeProto Proto { get; set; }
    }

    public partial class CartridgeProps
    {
        [JsonProperty("filters")]
        public PurpleFilter[] Filters { get; set; }
    }

    public partial class PurpleFilter
    {
        [JsonProperty("Filter")]
        public string[] Filter { get; set; }
    }

    public partial class Chamber
    {
        [JsonProperty("_name")]
        public ChamberName Name { get; set; }

        [JsonProperty("_id")]
        public string Id { get; set; }

        [JsonProperty("_parent")]
        public string Parent { get; set; }

        [JsonProperty("_props")]
        public ChamberProps Props { get; set; }

        [JsonProperty("_required")]
        public bool ChamberRequired { get; set; }

        [JsonProperty("_mergeSlotWithChildren")]
        public bool MergeSlotWithChildren { get; set; }

        [JsonProperty("_proto")]
        public ChamberProto Proto { get; set; }
    }

    public partial class ChamberProps
    {
        [JsonProperty("filters")]
        public FluffyFilter[] Filters { get; set; }
    }

    public partial class FluffyFilter
    {
        [JsonProperty("Filter")]
        public string[] Filter { get; set; }

        [JsonProperty("MaxStackCount", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxStackCount { get; set; }
    }

    public partial class Color
    {
        [JsonProperty("r")]
        public long R { get; set; }

        [JsonProperty("g")]
        public long G { get; set; }

        [JsonProperty("b")]
        public long B { get; set; }

        [JsonProperty("a")]
        public long A { get; set; }
    }

    public partial class EffectsDamageClass
    {
        [JsonProperty("Pain", NullValueHandling = NullValueHandling.Ignore)]
        public Contusion Pain { get; set; }

        [JsonProperty("RadExposure", NullValueHandling = NullValueHandling.Ignore)]
        public DestroyedPart RadExposure { get; set; }

        [JsonProperty("Intoxication", NullValueHandling = NullValueHandling.Ignore)]
        public Contusion Intoxication { get; set; }

        [JsonProperty("Contusion", NullValueHandling = NullValueHandling.Ignore)]
        public Contusion Contusion { get; set; }

        [JsonProperty("LightBleeding", NullValueHandling = NullValueHandling.Ignore)]
        public DestroyedPart LightBleeding { get; set; }

        [JsonProperty("HeavyBleeding", NullValueHandling = NullValueHandling.Ignore)]
        public DestroyedPart HeavyBleeding { get; set; }

        [JsonProperty("Fracture", NullValueHandling = NullValueHandling.Ignore)]
        public DestroyedPart Fracture { get; set; }

        [JsonProperty("DestroyedPart", NullValueHandling = NullValueHandling.Ignore)]
        public DestroyedPart DestroyedPart { get; set; }
    }

    public partial class Contusion
    {
        [JsonProperty("delay")]
        public long Delay { get; set; }

        [JsonProperty("duration")]
        public long Duration { get; set; }

        [JsonProperty("fadeOut", NullValueHandling = NullValueHandling.Ignore)]
        public long? FadeOut { get; set; }

        [JsonProperty("cost", NullValueHandling = NullValueHandling.Ignore)]
        public long? Cost { get; set; }
    }

    public partial class DestroyedPart
    {
        [JsonProperty("delay")]
        public long Delay { get; set; }

        [JsonProperty("duration")]
        public long Duration { get; set; }

        [JsonProperty("fadeOut", NullValueHandling = NullValueHandling.Ignore)]
        public long? FadeOut { get; set; }

        [JsonProperty("cost", NullValueHandling = NullValueHandling.Ignore)]
        public long? Cost { get; set; }

        [JsonProperty("healthPenaltyMin", NullValueHandling = NullValueHandling.Ignore)]
        public long? HealthPenaltyMin { get; set; }

        [JsonProperty("healthPenaltyMax", NullValueHandling = NullValueHandling.Ignore)]
        public long? HealthPenaltyMax { get; set; }
    }

    public partial class EffectsHealthElement
    {
        [JsonProperty("type")]
        public string Type { get; set; }

        [JsonProperty("value")]
        public long Value { get; set; }
    }

    public partial class PurpleEffectsHealth
    {
        [JsonProperty("Energy", NullValueHandling = NullValueHandling.Ignore)]
        public Energy Energy { get; set; }

        [JsonProperty("Hydration", NullValueHandling = NullValueHandling.Ignore)]
        public Energy Hydration { get; set; }
    }

    public partial class Energy
    {
        [JsonProperty("value")]
        public long Value { get; set; }
    }

    public partial class Grid
    {
        [JsonProperty("_name")]
        public NameUnion Name { get; set; }

        [JsonProperty("_id")]
        public string Id { get; set; }

        [JsonProperty("_parent")]
        public string Parent { get; set; }

        [JsonProperty("_props")]
        public GridProps Props { get; set; }

        [JsonProperty("_proto")]
        public GridProto Proto { get; set; }
    }

    public partial class GridProps
    {
        [JsonProperty("filters")]
        public TentacledFilter[] Filters { get; set; }

        [JsonProperty("cellsH")]
        public long CellsH { get; set; }

        [JsonProperty("cellsV")]
        public long CellsV { get; set; }

        [JsonProperty("minCount")]
        public long MinCount { get; set; }

        [JsonProperty("maxCount")]
        public long MaxCount { get; set; }

        [JsonProperty("maxWeight")]
        public long MaxWeight { get; set; }

        [JsonProperty("isSortingTable")]
        public bool IsSortingTable { get; set; }
    }

    public partial class TentacledFilter
    {
        [JsonProperty("Filter")]
        public string[] Filter { get; set; }

        [JsonProperty("ExcludedFilter")]
        public string[] ExcludedFilter { get; set; }
    }

    public partial class Prefab
    {
        [JsonProperty("path")]
        public string Path { get; set; }

        [JsonProperty("rcid")]
        public string Rcid { get; set; }
    }

    public partial class Slot
    {
        [JsonProperty("_name")]
        public string Name { get; set; }

        [JsonProperty("_id")]
        public string Id { get; set; }

        [JsonProperty("_parent")]
        public string Parent { get; set; }

        [JsonProperty("_props")]
        public SlotProps Props { get; set; }

        [JsonProperty("_required")]
        public bool SlotRequired { get; set; }

        [JsonProperty("_mergeSlotWithChildren")]
        public bool MergeSlotWithChildren { get; set; }

        [JsonProperty("_proto")]
        public ChamberProto Proto { get; set; }
    }

    public partial class SlotProps
    {
        [JsonProperty("filters")]
        public StickyFilter[] Filters { get; set; }
    }

    public partial class StickyFilter
    {
        [JsonProperty("Shift", NullValueHandling = NullValueHandling.Ignore)]
        public long? Shift { get; set; }

        [JsonProperty("Filter")]
        public string[] Filter { get; set; }

        [JsonProperty("MaxStackCount", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxStackCount { get; set; }

        [JsonProperty("AnimationIndex", NullValueHandling = NullValueHandling.Ignore)]
        public long? AnimationIndex { get; set; }
    }

    public enum AmmoSfx { Standart, Tracer, TracerRed };

    public enum AmmoType { Buckshot, Bullet, Grenade };

    public enum ArmorMaterial { Aluminium, Aramid, ArmoredSteel, Ceramic, Combined, Glass, Titan, Uhmwpe };

    public enum ArmorZone { Chest, Head, LeftArm, LeftLeg, RightArm, RightLeg, Stomach };

    public enum BackgroundColor { Black, Blue, Default, Green, Grey, Orange, Red, Violet, Yellow };

    public enum CartridgeName { Cartridges };

    public enum CartridgeProto { The5748538B2459770Af276A261 };

    public enum CasingSounds { PistolBig, PistolSmall, Rifle556, Rifle762, ShotgunBig, ShotgunSmall, The127Rifle, The40Mmgrenade, The50Cal };

    public enum ChamberName { PatronInWeapon, PatronInWeapon000, PatronInWeapon001 };

    public enum ChamberProto { The55D30C394Bdc2Dae468B4577, The55D30C4C4Bdc2Db4468B457E, The55D4Af244Bdc2D962F8B4571, The55D721144Bdc2D89028B456F };

    public enum CustomAimPlane { AkThermal, Default, Empty };

    public enum DeafStrength { High, Low, None };

    public enum DropSoundType { None, Pistol, Rifle, SubMachineGun };

    public enum ExplosionType { BigRoundImpact, BigRoundImpactExplosive, Empty, SmallgrenadeExpl };

    public enum FaceShieldMask { Narrow, NoMask, Wide };

    public enum FoldedSlot { Empty, ModStock, ModStock000, ModStock001, ModStockAkms, ModStockAxis };

    public enum DEffectType { AfterUse, DuringUse };

    public enum FragmentType { The5485A8684Bdc2Da71D8B4567, The5996F6Cb86F774678763A6Ca, The5996F6D686F77467977Ba6Cc, The5996F6Fc86F7745E585B4De3 };

    public enum GridLayoutName { Empty, F4Term, Gunslinger1, Oakley, Paratus };

    public enum NameName { Hideout, Main, Pocket1, Pocket2, Pocket3, Pocket4, Pocket5 };

    public enum GridProto { The55D329C24Bdc2D892F8B4567 };

    public enum HeadSegment { Ears, Eyes, Jaws, LowerNape, Nape, Top };

    public enum ItemSound { AmmoLauncher, AmmoPackGeneric, AmmoShotgun, AmmoSingleround, ContainerCase, ContainerMetal, ContainerPlastic, ContainerPouch, FoodBottle, FoodJuiceCarton, FoodSnack, FoodSodaCan, FoodTinCan, GearArmor, GearBackpack, GearGeneric, GearGoggles, GearHelmet, Generic, Grenade, ItemBook, ItemClothGeneric, ItemMap, ItemMoney, ItemPaper, ItemPlasticGeneric, Jewelry, Keys, KnifeGeneric, MagPlastic, MagazineBelt, MagazineDrum, MagazineMetal, MedBandage, MedMedkit, MedPills, MedStimulator, Mod, Smallmetal, SpecArmorrep, SpecKniferep, SpecMultitool, SpecWeaprep, WeapAr, WeapDmr, WeapPistol, WeapPump, WeapRifle };

    public enum MaterialType { BodyArmor, GlassVisor, Helmet };

    public enum MuzzleModType { Brake, Conpensator, MuzzleCombo, Pms, Silencer };

    public enum ReloadM { ExternalMagazine, InternalMagazine, OnlyBarrel };

    public enum SearchSound { CashregisterLooting, DrawerMetalLooting, DrawerWoodLooting, IndustrialboxLooting, JacketLooting, LootingBodyExtended, SafeLooting, SportbagLooting, TechnoBoxLooting01, WoodboxLooting };

    public enum SightModType { Holo, Hybrid, Iron, Optic, Reflex };

    public enum ThrowType { FlashGrenade, FragGrenade, SmokeGrenade };

    public enum TracerColor { Green, Red, TracerGreen, TracerRed, TracerYellow, Yellow };

    public enum UnlootableFromSide { Bear, Savage, Usec };

    public enum UnlootableFromSlot { ArmBand, FirstPrimaryWeapon, Holster, Scabbard, SpecialSlot };

    public enum VisibleAmmoRangesString { Empty, The111830, The112, The11446688101012121414161618182020, The114581013151820, The1148, The12, The121927, The125, The13, The141220 };

    public enum WeapClass { AssaultCarbine, AssaultRifle, GrenadeLauncher, Machinegun, MarksmanRifle, Pistol, Shotgun, Smg, SniperRifle, SpecialWeapon };

    public enum WeapFireType { Burst, Doubleaction, Doublet, Fullauto, Semiauto, Single };

    public enum WeapUseType { Primary, Secondary };

    public enum TypeEnum { Item, Node };

    public partial struct AimSensitivity
    {
        public double? Double;
        public double[][] DoubleArrayArray;

        public static implicit operator AimSensitivity(double Double) => new AimSensitivity { Double = Double };
        public static implicit operator AimSensitivity(double[][] DoubleArrayArray) => new AimSensitivity { DoubleArrayArray = DoubleArrayArray };
    }

    public partial struct EffectsDamageUnion
    {
        public object[] AnythingArray;
        public EffectsDamageClass EffectsDamageClass;

        public static implicit operator EffectsDamageUnion(object[] AnythingArray) => new EffectsDamageUnion { AnythingArray = AnythingArray };
        public static implicit operator EffectsDamageUnion(EffectsDamageClass EffectsDamageClass) => new EffectsDamageUnion { EffectsDamageClass = EffectsDamageClass };
    }

    public partial struct EffectsHealthUnion
    {
        public EffectsHealthElement[] EffectsHealthElementArray;
        public PurpleEffectsHealth PurpleEffectsHealth;

        public static implicit operator EffectsHealthUnion(EffectsHealthElement[] EffectsHealthElementArray) => new EffectsHealthUnion { EffectsHealthElementArray = EffectsHealthElementArray };
        public static implicit operator EffectsHealthUnion(PurpleEffectsHealth PurpleEffectsHealth) => new EffectsHealthUnion { PurpleEffectsHealth = PurpleEffectsHealth };
    }

    public partial struct NameUnion
    {
        public NameName? Enum;
        public long? Integer;

        public static implicit operator NameUnion(NameName Enum) => new NameUnion { Enum = Enum };
        public static implicit operator NameUnion(long Integer) => new NameUnion { Integer = Integer };
    }

    public partial struct ModesCount
    {
        public long? Integer;
        public long[] IntegerArray;

        public static implicit operator ModesCount(long Integer) => new ModesCount { Integer = Integer };
        public static implicit operator ModesCount(long[] IntegerArray) => new ModesCount { IntegerArray = IntegerArray };
    }

    public partial class ItemBase
    {
        public static System.Collections.Generic.Dictionary<string, ItemBase> FromJson(string json) => JsonConvert.DeserializeObject<System.Collections.Generic.Dictionary<string, ItemBase>>(json, Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this System.Collections.Generic.Dictionary<string, ItemBase> self) => JsonConvert.SerializeObject(self, Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                AimSensitivityConverter.Converter,
                ArmorMaterialConverter.Converter,
                BackgroundColorConverter.Converter,
                CartridgeNameConverter.Converter,
                CartridgeProtoConverter.Converter,
                ChamberNameConverter.Converter,
                ChamberProtoConverter.Converter,
                CustomAimPlaneConverter.Converter,
                DeafStrengthConverter.Converter,
                DropSoundTypeConverter.Converter,
                ExplosionTypeConverter.Converter,
                FaceShieldMaskConverter.Converter,
                FoldedSlotConverter.Converter,
                FragmentTypeConverter.Converter,
                GridLayoutNameConverter.Converter,
                NameUnionConverter.Converter,
                NameNameConverter.Converter,
                GridProtoConverter.Converter,
                ItemSoundConverter.Converter,
                MaterialTypeConverter.Converter,
                ModesCountConverter.Converter,
                ReloadMConverter.Converter,
                SearchSoundConverter.Converter,
                ThrowTypeConverter.Converter,
                TracerColorConverter.Converter,
                UnlootableFromSideConverter.Converter,
                UnlootableFromSlotConverter.Converter,
                VisibleAmmoRangesStringConverter.Converter,
                AmmoSfxConverter.Converter,
                AmmoTypeConverter.Converter,
                ArmorZoneConverter.Converter,
                CasingSoundsConverter.Converter,
                EffectsDamageUnionConverter.Converter,
                EffectsHealthUnionConverter.Converter,
                DEffectTypeConverter.Converter,
                HeadSegmentConverter.Converter,
                MuzzleModTypeConverter.Converter,
                SightModTypeConverter.Converter,
                WeapClassConverter.Converter,
                WeapFireTypeConverter.Converter,
                WeapUseTypeConverter.Converter,
                TypeEnumConverter.Converter,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class AimSensitivityConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AimSensitivity) || t == typeof(AimSensitivity?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new AimSensitivity { Double = doubleValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<double[][]>(reader);
                    return new AimSensitivity { DoubleArrayArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type AimSensitivity");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (AimSensitivity)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.DoubleArrayArray != null)
            {
                serializer.Serialize(writer, value.DoubleArrayArray);
                return;
            }
            throw new Exception("Cannot marshal type AimSensitivity");
        }

        public static readonly AimSensitivityConverter Converter = new AimSensitivityConverter();
    }

    internal class ArmorMaterialConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ArmorMaterial) || t == typeof(ArmorMaterial?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Aluminium":
                    return ArmorMaterial.Aluminium;
                case "Aramid":
                    return ArmorMaterial.Aramid;
                case "ArmoredSteel":
                    return ArmorMaterial.ArmoredSteel;
                case "Ceramic":
                    return ArmorMaterial.Ceramic;
                case "Combined":
                    return ArmorMaterial.Combined;
                case "Glass":
                    return ArmorMaterial.Glass;
                case "Titan":
                    return ArmorMaterial.Titan;
                case "UHMWPE":
                    return ArmorMaterial.Uhmwpe;
            }
            throw new Exception("Cannot unmarshal type ArmorMaterial");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ArmorMaterial)untypedValue;
            switch (value)
            {
                case ArmorMaterial.Aluminium:
                    serializer.Serialize(writer, "Aluminium");
                    return;
                case ArmorMaterial.Aramid:
                    serializer.Serialize(writer, "Aramid");
                    return;
                case ArmorMaterial.ArmoredSteel:
                    serializer.Serialize(writer, "ArmoredSteel");
                    return;
                case ArmorMaterial.Ceramic:
                    serializer.Serialize(writer, "Ceramic");
                    return;
                case ArmorMaterial.Combined:
                    serializer.Serialize(writer, "Combined");
                    return;
                case ArmorMaterial.Glass:
                    serializer.Serialize(writer, "Glass");
                    return;
                case ArmorMaterial.Titan:
                    serializer.Serialize(writer, "Titan");
                    return;
                case ArmorMaterial.Uhmwpe:
                    serializer.Serialize(writer, "UHMWPE");
                    return;
            }
            throw new Exception("Cannot marshal type ArmorMaterial");
        }

        public static readonly ArmorMaterialConverter Converter = new ArmorMaterialConverter();
    }

    internal class BackgroundColorConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BackgroundColor) || t == typeof(BackgroundColor?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "black":
                    return BackgroundColor.Black;
                case "blue":
                    return BackgroundColor.Blue;
                case "default":
                    return BackgroundColor.Default;
                case "green":
                    return BackgroundColor.Green;
                case "grey":
                    return BackgroundColor.Grey;
                case "orange":
                    return BackgroundColor.Orange;
                case "red":
                    return BackgroundColor.Red;
                case "violet":
                    return BackgroundColor.Violet;
                case "yellow":
                    return BackgroundColor.Yellow;
            }
            throw new Exception("Cannot unmarshal type BackgroundColor");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BackgroundColor)untypedValue;
            switch (value)
            {
                case BackgroundColor.Black:
                    serializer.Serialize(writer, "black");
                    return;
                case BackgroundColor.Blue:
                    serializer.Serialize(writer, "blue");
                    return;
                case BackgroundColor.Default:
                    serializer.Serialize(writer, "default");
                    return;
                case BackgroundColor.Green:
                    serializer.Serialize(writer, "green");
                    return;
                case BackgroundColor.Grey:
                    serializer.Serialize(writer, "grey");
                    return;
                case BackgroundColor.Orange:
                    serializer.Serialize(writer, "orange");
                    return;
                case BackgroundColor.Red:
                    serializer.Serialize(writer, "red");
                    return;
                case BackgroundColor.Violet:
                    serializer.Serialize(writer, "violet");
                    return;
                case BackgroundColor.Yellow:
                    serializer.Serialize(writer, "yellow");
                    return;
            }
            throw new Exception("Cannot marshal type BackgroundColor");
        }

        public static readonly BackgroundColorConverter Converter = new BackgroundColorConverter();
    }

    internal class CartridgeNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CartridgeName) || t == typeof(CartridgeName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "cartridges")
            {
                return CartridgeName.Cartridges;
            }
            throw new Exception("Cannot unmarshal type CartridgeName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CartridgeName)untypedValue;
            if (value == CartridgeName.Cartridges)
            {
                serializer.Serialize(writer, "cartridges");
                return;
            }
            throw new Exception("Cannot marshal type CartridgeName");
        }

        public static readonly CartridgeNameConverter Converter = new CartridgeNameConverter();
    }

    internal class CartridgeProtoConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CartridgeProto) || t == typeof(CartridgeProto?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "5748538b2459770af276a261")
            {
                return CartridgeProto.The5748538B2459770Af276A261;
            }
            throw new Exception("Cannot unmarshal type CartridgeProto");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CartridgeProto)untypedValue;
            if (value == CartridgeProto.The5748538B2459770Af276A261)
            {
                serializer.Serialize(writer, "5748538b2459770af276a261");
                return;
            }
            throw new Exception("Cannot marshal type CartridgeProto");
        }

        public static readonly CartridgeProtoConverter Converter = new CartridgeProtoConverter();
    }

    internal class ChamberNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ChamberName) || t == typeof(ChamberName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "patron_in_weapon":
                    return ChamberName.PatronInWeapon;
                case "patron_in_weapon_000":
                    return ChamberName.PatronInWeapon000;
                case "patron_in_weapon_001":
                    return ChamberName.PatronInWeapon001;
            }
            throw new Exception("Cannot unmarshal type ChamberName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ChamberName)untypedValue;
            switch (value)
            {
                case ChamberName.PatronInWeapon:
                    serializer.Serialize(writer, "patron_in_weapon");
                    return;
                case ChamberName.PatronInWeapon000:
                    serializer.Serialize(writer, "patron_in_weapon_000");
                    return;
                case ChamberName.PatronInWeapon001:
                    serializer.Serialize(writer, "patron_in_weapon_001");
                    return;
            }
            throw new Exception("Cannot marshal type ChamberName");
        }

        public static readonly ChamberNameConverter Converter = new ChamberNameConverter();
    }

    internal class ChamberProtoConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ChamberProto) || t == typeof(ChamberProto?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "55d30c394bdc2dae468b4577":
                    return ChamberProto.The55D30C394Bdc2Dae468B4577;
                case "55d30c4c4bdc2db4468b457e":
                    return ChamberProto.The55D30C4C4Bdc2Db4468B457E;
                case "55d4af244bdc2d962f8b4571":
                    return ChamberProto.The55D4Af244Bdc2D962F8B4571;
                case "55d721144bdc2d89028b456f":
                    return ChamberProto.The55D721144Bdc2D89028B456F;
            }
            throw new Exception("Cannot unmarshal type ChamberProto");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ChamberProto)untypedValue;
            switch (value)
            {
                case ChamberProto.The55D30C394Bdc2Dae468B4577:
                    serializer.Serialize(writer, "55d30c394bdc2dae468b4577");
                    return;
                case ChamberProto.The55D30C4C4Bdc2Db4468B457E:
                    serializer.Serialize(writer, "55d30c4c4bdc2db4468b457e");
                    return;
                case ChamberProto.The55D4Af244Bdc2D962F8B4571:
                    serializer.Serialize(writer, "55d4af244bdc2d962f8b4571");
                    return;
                case ChamberProto.The55D721144Bdc2D89028B456F:
                    serializer.Serialize(writer, "55d721144bdc2d89028b456f");
                    return;
            }
            throw new Exception("Cannot marshal type ChamberProto");
        }

        public static readonly ChamberProtoConverter Converter = new ChamberProtoConverter();
    }

    internal class CustomAimPlaneConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CustomAimPlane) || t == typeof(CustomAimPlane?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return CustomAimPlane.Empty;
                case "ak_thermal":
                    return CustomAimPlane.AkThermal;
                case "default":
                    return CustomAimPlane.Default;
            }
            throw new Exception("Cannot unmarshal type CustomAimPlane");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CustomAimPlane)untypedValue;
            switch (value)
            {
                case CustomAimPlane.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case CustomAimPlane.AkThermal:
                    serializer.Serialize(writer, "ak_thermal");
                    return;
                case CustomAimPlane.Default:
                    serializer.Serialize(writer, "default");
                    return;
            }
            throw new Exception("Cannot marshal type CustomAimPlane");
        }

        public static readonly CustomAimPlaneConverter Converter = new CustomAimPlaneConverter();
    }

    internal class DeafStrengthConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DeafStrength) || t == typeof(DeafStrength?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "High":
                    return DeafStrength.High;
                case "Low":
                    return DeafStrength.Low;
                case "None":
                    return DeafStrength.None;
            }
            throw new Exception("Cannot unmarshal type DeafStrength");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DeafStrength)untypedValue;
            switch (value)
            {
                case DeafStrength.High:
                    serializer.Serialize(writer, "High");
                    return;
                case DeafStrength.Low:
                    serializer.Serialize(writer, "Low");
                    return;
                case DeafStrength.None:
                    serializer.Serialize(writer, "None");
                    return;
            }
            throw new Exception("Cannot marshal type DeafStrength");
        }

        public static readonly DeafStrengthConverter Converter = new DeafStrengthConverter();
    }

    internal class DropSoundTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DropSoundType) || t == typeof(DropSoundType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "None":
                    return DropSoundType.None;
                case "Pistol":
                    return DropSoundType.Pistol;
                case "Rifle":
                    return DropSoundType.Rifle;
                case "SubMachineGun":
                    return DropSoundType.SubMachineGun;
            }
            throw new Exception("Cannot unmarshal type DropSoundType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DropSoundType)untypedValue;
            switch (value)
            {
                case DropSoundType.None:
                    serializer.Serialize(writer, "None");
                    return;
                case DropSoundType.Pistol:
                    serializer.Serialize(writer, "Pistol");
                    return;
                case DropSoundType.Rifle:
                    serializer.Serialize(writer, "Rifle");
                    return;
                case DropSoundType.SubMachineGun:
                    serializer.Serialize(writer, "SubMachineGun");
                    return;
            }
            throw new Exception("Cannot marshal type DropSoundType");
        }

        public static readonly DropSoundTypeConverter Converter = new DropSoundTypeConverter();
    }

    internal class ExplosionTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ExplosionType) || t == typeof(ExplosionType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return ExplosionType.Empty;
                case "big_round_impact":
                    return ExplosionType.BigRoundImpact;
                case "big_round_impact_explosive":
                    return ExplosionType.BigRoundImpactExplosive;
                case "smallgrenade_expl":
                    return ExplosionType.SmallgrenadeExpl;
            }
            throw new Exception("Cannot unmarshal type ExplosionType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ExplosionType)untypedValue;
            switch (value)
            {
                case ExplosionType.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case ExplosionType.BigRoundImpact:
                    serializer.Serialize(writer, "big_round_impact");
                    return;
                case ExplosionType.BigRoundImpactExplosive:
                    serializer.Serialize(writer, "big_round_impact_explosive");
                    return;
                case ExplosionType.SmallgrenadeExpl:
                    serializer.Serialize(writer, "smallgrenade_expl");
                    return;
            }
            throw new Exception("Cannot marshal type ExplosionType");
        }

        public static readonly ExplosionTypeConverter Converter = new ExplosionTypeConverter();
    }

    internal class FaceShieldMaskConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FaceShieldMask) || t == typeof(FaceShieldMask?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Narrow":
                    return FaceShieldMask.Narrow;
                case "NoMask":
                    return FaceShieldMask.NoMask;
                case "Wide":
                    return FaceShieldMask.Wide;
            }
            throw new Exception("Cannot unmarshal type FaceShieldMask");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FaceShieldMask)untypedValue;
            switch (value)
            {
                case FaceShieldMask.Narrow:
                    serializer.Serialize(writer, "Narrow");
                    return;
                case FaceShieldMask.NoMask:
                    serializer.Serialize(writer, "NoMask");
                    return;
                case FaceShieldMask.Wide:
                    serializer.Serialize(writer, "Wide");
                    return;
            }
            throw new Exception("Cannot marshal type FaceShieldMask");
        }

        public static readonly FaceShieldMaskConverter Converter = new FaceShieldMaskConverter();
    }

    internal class FoldedSlotConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FoldedSlot) || t == typeof(FoldedSlot?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return FoldedSlot.Empty;
                case "mod_stock":
                    return FoldedSlot.ModStock;
                case "mod_stock_000":
                    return FoldedSlot.ModStock000;
                case "mod_stock_001":
                    return FoldedSlot.ModStock001;
                case "mod_stock_akms":
                    return FoldedSlot.ModStockAkms;
                case "mod_stock_axis":
                    return FoldedSlot.ModStockAxis;
            }
            throw new Exception("Cannot unmarshal type FoldedSlot");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FoldedSlot)untypedValue;
            switch (value)
            {
                case FoldedSlot.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case FoldedSlot.ModStock:
                    serializer.Serialize(writer, "mod_stock");
                    return;
                case FoldedSlot.ModStock000:
                    serializer.Serialize(writer, "mod_stock_000");
                    return;
                case FoldedSlot.ModStock001:
                    serializer.Serialize(writer, "mod_stock_001");
                    return;
                case FoldedSlot.ModStockAkms:
                    serializer.Serialize(writer, "mod_stock_akms");
                    return;
                case FoldedSlot.ModStockAxis:
                    serializer.Serialize(writer, "mod_stock_axis");
                    return;
            }
            throw new Exception("Cannot marshal type FoldedSlot");
        }

        public static readonly FoldedSlotConverter Converter = new FoldedSlotConverter();
    }

    internal class FragmentTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FragmentType) || t == typeof(FragmentType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "5485a8684bdc2da71d8b4567":
                    return FragmentType.The5485A8684Bdc2Da71D8B4567;
                case "5996f6cb86f774678763a6ca":
                    return FragmentType.The5996F6Cb86F774678763A6Ca;
                case "5996f6d686f77467977ba6cc":
                    return FragmentType.The5996F6D686F77467977Ba6Cc;
                case "5996f6fc86f7745e585b4de3":
                    return FragmentType.The5996F6Fc86F7745E585B4De3;
            }
            throw new Exception("Cannot unmarshal type FragmentType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FragmentType)untypedValue;
            switch (value)
            {
                case FragmentType.The5485A8684Bdc2Da71D8B4567:
                    serializer.Serialize(writer, "5485a8684bdc2da71d8b4567");
                    return;
                case FragmentType.The5996F6Cb86F774678763A6Ca:
                    serializer.Serialize(writer, "5996f6cb86f774678763a6ca");
                    return;
                case FragmentType.The5996F6D686F77467977Ba6Cc:
                    serializer.Serialize(writer, "5996f6d686f77467977ba6cc");
                    return;
                case FragmentType.The5996F6Fc86F7745E585B4De3:
                    serializer.Serialize(writer, "5996f6fc86f7745e585b4de3");
                    return;
            }
            throw new Exception("Cannot marshal type FragmentType");
        }

        public static readonly FragmentTypeConverter Converter = new FragmentTypeConverter();
    }

    internal class GridLayoutNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(GridLayoutName) || t == typeof(GridLayoutName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return GridLayoutName.Empty;
                case "Paratus":
                    return GridLayoutName.Paratus;
                case "f4_term":
                    return GridLayoutName.F4Term;
                case "gunslinger1":
                    return GridLayoutName.Gunslinger1;
                case "oakley":
                    return GridLayoutName.Oakley;
            }
            throw new Exception("Cannot unmarshal type GridLayoutName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (GridLayoutName)untypedValue;
            switch (value)
            {
                case GridLayoutName.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case GridLayoutName.Paratus:
                    serializer.Serialize(writer, "Paratus");
                    return;
                case GridLayoutName.F4Term:
                    serializer.Serialize(writer, "f4_term");
                    return;
                case GridLayoutName.Gunslinger1:
                    serializer.Serialize(writer, "gunslinger1");
                    return;
                case GridLayoutName.Oakley:
                    serializer.Serialize(writer, "oakley");
                    return;
            }
            throw new Exception("Cannot marshal type GridLayoutName");
        }

        public static readonly GridLayoutNameConverter Converter = new GridLayoutNameConverter();
    }

    internal class NameUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(NameUnion) || t == typeof(NameUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "hideout":
                            return new NameUnion { Enum = NameName.Hideout };
                        case "main":
                            return new NameUnion { Enum = NameName.Main };
                        case "pocket1":
                            return new NameUnion { Enum = NameName.Pocket1 };
                        case "pocket2":
                            return new NameUnion { Enum = NameName.Pocket2 };
                        case "pocket3":
                            return new NameUnion { Enum = NameName.Pocket3 };
                        case "pocket4":
                            return new NameUnion { Enum = NameName.Pocket4 };
                        case "pocket5":
                            return new NameUnion { Enum = NameName.Pocket5 };
                    }
                    long l;
                    if (Int64.TryParse(stringValue, out l))
                    {
                        return new NameUnion { Integer = l };
                    }
                    break;
            }
            throw new Exception("Cannot unmarshal type NameUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (NameUnion)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case NameName.Hideout:
                        serializer.Serialize(writer, "hideout");
                        return;
                    case NameName.Main:
                        serializer.Serialize(writer, "main");
                        return;
                    case NameName.Pocket1:
                        serializer.Serialize(writer, "pocket1");
                        return;
                    case NameName.Pocket2:
                        serializer.Serialize(writer, "pocket2");
                        return;
                    case NameName.Pocket3:
                        serializer.Serialize(writer, "pocket3");
                        return;
                    case NameName.Pocket4:
                        serializer.Serialize(writer, "pocket4");
                        return;
                    case NameName.Pocket5:
                        serializer.Serialize(writer, "pocket5");
                        return;
                }
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value.ToString());
                return;
            }
            throw new Exception("Cannot marshal type NameUnion");
        }

        public static readonly NameUnionConverter Converter = new NameUnionConverter();
    }

    internal class NameNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(NameName) || t == typeof(NameName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "hideout":
                    return NameName.Hideout;
                case "main":
                    return NameName.Main;
                case "pocket1":
                    return NameName.Pocket1;
                case "pocket2":
                    return NameName.Pocket2;
                case "pocket3":
                    return NameName.Pocket3;
                case "pocket4":
                    return NameName.Pocket4;
                case "pocket5":
                    return NameName.Pocket5;
            }
            throw new Exception("Cannot unmarshal type NameName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (NameName)untypedValue;
            switch (value)
            {
                case NameName.Hideout:
                    serializer.Serialize(writer, "hideout");
                    return;
                case NameName.Main:
                    serializer.Serialize(writer, "main");
                    return;
                case NameName.Pocket1:
                    serializer.Serialize(writer, "pocket1");
                    return;
                case NameName.Pocket2:
                    serializer.Serialize(writer, "pocket2");
                    return;
                case NameName.Pocket3:
                    serializer.Serialize(writer, "pocket3");
                    return;
                case NameName.Pocket4:
                    serializer.Serialize(writer, "pocket4");
                    return;
                case NameName.Pocket5:
                    serializer.Serialize(writer, "pocket5");
                    return;
            }
            throw new Exception("Cannot marshal type NameName");
        }

        public static readonly NameNameConverter Converter = new NameNameConverter();
    }

    internal class GridProtoConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(GridProto) || t == typeof(GridProto?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "55d329c24bdc2d892f8b4567")
            {
                return GridProto.The55D329C24Bdc2D892F8B4567;
            }
            throw new Exception("Cannot unmarshal type GridProto");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (GridProto)untypedValue;
            if (value == GridProto.The55D329C24Bdc2D892F8B4567)
            {
                serializer.Serialize(writer, "55d329c24bdc2d892f8b4567");
                return;
            }
            throw new Exception("Cannot marshal type GridProto");
        }

        public static readonly GridProtoConverter Converter = new GridProtoConverter();
    }

    internal class ItemSoundConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ItemSound) || t == typeof(ItemSound?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ammo_launcher":
                    return ItemSound.AmmoLauncher;
                case "ammo_pack_generic":
                    return ItemSound.AmmoPackGeneric;
                case "ammo_shotgun":
                    return ItemSound.AmmoShotgun;
                case "ammo_singleround":
                    return ItemSound.AmmoSingleround;
                case "container_case":
                    return ItemSound.ContainerCase;
                case "container_metal":
                    return ItemSound.ContainerMetal;
                case "container_plastic":
                    return ItemSound.ContainerPlastic;
                case "container_pouch":
                    return ItemSound.ContainerPouch;
                case "food_bottle":
                    return ItemSound.FoodBottle;
                case "food_juice_carton":
                    return ItemSound.FoodJuiceCarton;
                case "food_snack":
                    return ItemSound.FoodSnack;
                case "food_soda_can":
                    return ItemSound.FoodSodaCan;
                case "food_tin_can":
                    return ItemSound.FoodTinCan;
                case "gear_armor":
                    return ItemSound.GearArmor;
                case "gear_backpack":
                    return ItemSound.GearBackpack;
                case "gear_generic":
                    return ItemSound.GearGeneric;
                case "gear_goggles":
                    return ItemSound.GearGoggles;
                case "gear_helmet":
                    return ItemSound.GearHelmet;
                case "generic":
                    return ItemSound.Generic;
                case "grenade":
                    return ItemSound.Grenade;
                case "item_book":
                    return ItemSound.ItemBook;
                case "item_cloth_generic":
                    return ItemSound.ItemClothGeneric;
                case "item_map":
                    return ItemSound.ItemMap;
                case "item_money":
                    return ItemSound.ItemMoney;
                case "item_paper":
                    return ItemSound.ItemPaper;
                case "item_plastic_generic":
                    return ItemSound.ItemPlasticGeneric;
                case "jewelry":
                    return ItemSound.Jewelry;
                case "keys":
                    return ItemSound.Keys;
                case "knife_generic":
                    return ItemSound.KnifeGeneric;
                case "mag_plastic":
                    return ItemSound.MagPlastic;
                case "magazine_belt":
                    return ItemSound.MagazineBelt;
                case "magazine_drum":
                    return ItemSound.MagazineDrum;
                case "magazine_metal":
                    return ItemSound.MagazineMetal;
                case "med_bandage":
                    return ItemSound.MedBandage;
                case "med_medkit":
                    return ItemSound.MedMedkit;
                case "med_pills":
                    return ItemSound.MedPills;
                case "med_stimulator":
                    return ItemSound.MedStimulator;
                case "mod":
                    return ItemSound.Mod;
                case "smallmetal":
                    return ItemSound.Smallmetal;
                case "spec_armorrep":
                    return ItemSound.SpecArmorrep;
                case "spec_kniferep":
                    return ItemSound.SpecKniferep;
                case "spec_multitool":
                    return ItemSound.SpecMultitool;
                case "spec_weaprep":
                    return ItemSound.SpecWeaprep;
                case "weap_ar":
                    return ItemSound.WeapAr;
                case "weap_dmr":
                    return ItemSound.WeapDmr;
                case "weap_pistol":
                    return ItemSound.WeapPistol;
                case "weap_pump":
                    return ItemSound.WeapPump;
                case "weap_rifle":
                    return ItemSound.WeapRifle;
            }
            throw new Exception("Cannot unmarshal type ItemSound");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ItemSound)untypedValue;
            switch (value)
            {
                case ItemSound.AmmoLauncher:
                    serializer.Serialize(writer, "ammo_launcher");
                    return;
                case ItemSound.AmmoPackGeneric:
                    serializer.Serialize(writer, "ammo_pack_generic");
                    return;
                case ItemSound.AmmoShotgun:
                    serializer.Serialize(writer, "ammo_shotgun");
                    return;
                case ItemSound.AmmoSingleround:
                    serializer.Serialize(writer, "ammo_singleround");
                    return;
                case ItemSound.ContainerCase:
                    serializer.Serialize(writer, "container_case");
                    return;
                case ItemSound.ContainerMetal:
                    serializer.Serialize(writer, "container_metal");
                    return;
                case ItemSound.ContainerPlastic:
                    serializer.Serialize(writer, "container_plastic");
                    return;
                case ItemSound.ContainerPouch:
                    serializer.Serialize(writer, "container_pouch");
                    return;
                case ItemSound.FoodBottle:
                    serializer.Serialize(writer, "food_bottle");
                    return;
                case ItemSound.FoodJuiceCarton:
                    serializer.Serialize(writer, "food_juice_carton");
                    return;
                case ItemSound.FoodSnack:
                    serializer.Serialize(writer, "food_snack");
                    return;
                case ItemSound.FoodSodaCan:
                    serializer.Serialize(writer, "food_soda_can");
                    return;
                case ItemSound.FoodTinCan:
                    serializer.Serialize(writer, "food_tin_can");
                    return;
                case ItemSound.GearArmor:
                    serializer.Serialize(writer, "gear_armor");
                    return;
                case ItemSound.GearBackpack:
                    serializer.Serialize(writer, "gear_backpack");
                    return;
                case ItemSound.GearGeneric:
                    serializer.Serialize(writer, "gear_generic");
                    return;
                case ItemSound.GearGoggles:
                    serializer.Serialize(writer, "gear_goggles");
                    return;
                case ItemSound.GearHelmet:
                    serializer.Serialize(writer, "gear_helmet");
                    return;
                case ItemSound.Generic:
                    serializer.Serialize(writer, "generic");
                    return;
                case ItemSound.Grenade:
                    serializer.Serialize(writer, "grenade");
                    return;
                case ItemSound.ItemBook:
                    serializer.Serialize(writer, "item_book");
                    return;
                case ItemSound.ItemClothGeneric:
                    serializer.Serialize(writer, "item_cloth_generic");
                    return;
                case ItemSound.ItemMap:
                    serializer.Serialize(writer, "item_map");
                    return;
                case ItemSound.ItemMoney:
                    serializer.Serialize(writer, "item_money");
                    return;
                case ItemSound.ItemPaper:
                    serializer.Serialize(writer, "item_paper");
                    return;
                case ItemSound.ItemPlasticGeneric:
                    serializer.Serialize(writer, "item_plastic_generic");
                    return;
                case ItemSound.Jewelry:
                    serializer.Serialize(writer, "jewelry");
                    return;
                case ItemSound.Keys:
                    serializer.Serialize(writer, "keys");
                    return;
                case ItemSound.KnifeGeneric:
                    serializer.Serialize(writer, "knife_generic");
                    return;
                case ItemSound.MagPlastic:
                    serializer.Serialize(writer, "mag_plastic");
                    return;
                case ItemSound.MagazineBelt:
                    serializer.Serialize(writer, "magazine_belt");
                    return;
                case ItemSound.MagazineDrum:
                    serializer.Serialize(writer, "magazine_drum");
                    return;
                case ItemSound.MagazineMetal:
                    serializer.Serialize(writer, "magazine_metal");
                    return;
                case ItemSound.MedBandage:
                    serializer.Serialize(writer, "med_bandage");
                    return;
                case ItemSound.MedMedkit:
                    serializer.Serialize(writer, "med_medkit");
                    return;
                case ItemSound.MedPills:
                    serializer.Serialize(writer, "med_pills");
                    return;
                case ItemSound.MedStimulator:
                    serializer.Serialize(writer, "med_stimulator");
                    return;
                case ItemSound.Mod:
                    serializer.Serialize(writer, "mod");
                    return;
                case ItemSound.Smallmetal:
                    serializer.Serialize(writer, "smallmetal");
                    return;
                case ItemSound.SpecArmorrep:
                    serializer.Serialize(writer, "spec_armorrep");
                    return;
                case ItemSound.SpecKniferep:
                    serializer.Serialize(writer, "spec_kniferep");
                    return;
                case ItemSound.SpecMultitool:
                    serializer.Serialize(writer, "spec_multitool");
                    return;
                case ItemSound.SpecWeaprep:
                    serializer.Serialize(writer, "spec_weaprep");
                    return;
                case ItemSound.WeapAr:
                    serializer.Serialize(writer, "weap_ar");
                    return;
                case ItemSound.WeapDmr:
                    serializer.Serialize(writer, "weap_dmr");
                    return;
                case ItemSound.WeapPistol:
                    serializer.Serialize(writer, "weap_pistol");
                    return;
                case ItemSound.WeapPump:
                    serializer.Serialize(writer, "weap_pump");
                    return;
                case ItemSound.WeapRifle:
                    serializer.Serialize(writer, "weap_rifle");
                    return;
            }
            throw new Exception("Cannot marshal type ItemSound");
        }

        public static readonly ItemSoundConverter Converter = new ItemSoundConverter();
    }

    internal class MaterialTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(MaterialType) || t == typeof(MaterialType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "BodyArmor":
                    return MaterialType.BodyArmor;
                case "GlassVisor":
                    return MaterialType.GlassVisor;
                case "Helmet":
                    return MaterialType.Helmet;
            }
            throw new Exception("Cannot unmarshal type MaterialType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (MaterialType)untypedValue;
            switch (value)
            {
                case MaterialType.BodyArmor:
                    serializer.Serialize(writer, "BodyArmor");
                    return;
                case MaterialType.GlassVisor:
                    serializer.Serialize(writer, "GlassVisor");
                    return;
                case MaterialType.Helmet:
                    serializer.Serialize(writer, "Helmet");
                    return;
            }
            throw new Exception("Cannot marshal type MaterialType");
        }

        public static readonly MaterialTypeConverter Converter = new MaterialTypeConverter();
    }

    internal class ModesCountConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ModesCount) || t == typeof(ModesCount?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new ModesCount { Integer = integerValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<long[]>(reader);
                    return new ModesCount { IntegerArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type ModesCount");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ModesCount)untypedValue;
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.IntegerArray != null)
            {
                serializer.Serialize(writer, value.IntegerArray);
                return;
            }
            throw new Exception("Cannot marshal type ModesCount");
        }

        public static readonly ModesCountConverter Converter = new ModesCountConverter();
    }

    internal class ReloadMConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ReloadM) || t == typeof(ReloadM?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ExternalMagazine":
                    return ReloadM.ExternalMagazine;
                case "InternalMagazine":
                    return ReloadM.InternalMagazine;
                case "OnlyBarrel":
                    return ReloadM.OnlyBarrel;
            }
            throw new Exception("Cannot unmarshal type ReloadM");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ReloadM)untypedValue;
            switch (value)
            {
                case ReloadM.ExternalMagazine:
                    serializer.Serialize(writer, "ExternalMagazine");
                    return;
                case ReloadM.InternalMagazine:
                    serializer.Serialize(writer, "InternalMagazine");
                    return;
                case ReloadM.OnlyBarrel:
                    serializer.Serialize(writer, "OnlyBarrel");
                    return;
            }
            throw new Exception("Cannot marshal type ReloadM");
        }

        public static readonly ReloadMConverter Converter = new ReloadMConverter();
    }

    internal class SearchSoundConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SearchSound) || t == typeof(SearchSound?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "cashregister_looting":
                    return SearchSound.CashregisterLooting;
                case "drawer_metal_looting":
                    return SearchSound.DrawerMetalLooting;
                case "drawer_wood_looting":
                    return SearchSound.DrawerWoodLooting;
                case "industrialbox_looting":
                    return SearchSound.IndustrialboxLooting;
                case "jacket_looting":
                    return SearchSound.JacketLooting;
                case "looting_body_extended":
                    return SearchSound.LootingBodyExtended;
                case "safe_looting":
                    return SearchSound.SafeLooting;
                case "sportbag_looting":
                    return SearchSound.SportbagLooting;
                case "techno_box_looting_01":
                    return SearchSound.TechnoBoxLooting01;
                case "woodbox_looting":
                    return SearchSound.WoodboxLooting;
            }
            throw new Exception("Cannot unmarshal type SearchSound");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SearchSound)untypedValue;
            switch (value)
            {
                case SearchSound.CashregisterLooting:
                    serializer.Serialize(writer, "cashregister_looting");
                    return;
                case SearchSound.DrawerMetalLooting:
                    serializer.Serialize(writer, "drawer_metal_looting");
                    return;
                case SearchSound.DrawerWoodLooting:
                    serializer.Serialize(writer, "drawer_wood_looting");
                    return;
                case SearchSound.IndustrialboxLooting:
                    serializer.Serialize(writer, "industrialbox_looting");
                    return;
                case SearchSound.JacketLooting:
                    serializer.Serialize(writer, "jacket_looting");
                    return;
                case SearchSound.LootingBodyExtended:
                    serializer.Serialize(writer, "looting_body_extended");
                    return;
                case SearchSound.SafeLooting:
                    serializer.Serialize(writer, "safe_looting");
                    return;
                case SearchSound.SportbagLooting:
                    serializer.Serialize(writer, "sportbag_looting");
                    return;
                case SearchSound.TechnoBoxLooting01:
                    serializer.Serialize(writer, "techno_box_looting_01");
                    return;
                case SearchSound.WoodboxLooting:
                    serializer.Serialize(writer, "woodbox_looting");
                    return;
            }
            throw new Exception("Cannot marshal type SearchSound");
        }

        public static readonly SearchSoundConverter Converter = new SearchSoundConverter();
    }

    internal class ThrowTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ThrowType) || t == typeof(ThrowType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "flash_grenade":
                    return ThrowType.FlashGrenade;
                case "frag_grenade":
                    return ThrowType.FragGrenade;
                case "smoke_grenade":
                    return ThrowType.SmokeGrenade;
            }
            throw new Exception("Cannot unmarshal type ThrowType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ThrowType)untypedValue;
            switch (value)
            {
                case ThrowType.FlashGrenade:
                    serializer.Serialize(writer, "flash_grenade");
                    return;
                case ThrowType.FragGrenade:
                    serializer.Serialize(writer, "frag_grenade");
                    return;
                case ThrowType.SmokeGrenade:
                    serializer.Serialize(writer, "smoke_grenade");
                    return;
            }
            throw new Exception("Cannot marshal type ThrowType");
        }

        public static readonly ThrowTypeConverter Converter = new ThrowTypeConverter();
    }

    internal class TracerColorConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TracerColor) || t == typeof(TracerColor?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "green":
                    return TracerColor.Green;
                case "red":
                    return TracerColor.Red;
                case "tracerGreen":
                    return TracerColor.TracerGreen;
                case "tracerRed":
                    return TracerColor.TracerRed;
                case "tracerYellow":
                    return TracerColor.TracerYellow;
                case "yellow":
                    return TracerColor.Yellow;
            }
            throw new Exception("Cannot unmarshal type TracerColor");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TracerColor)untypedValue;
            switch (value)
            {
                case TracerColor.Green:
                    serializer.Serialize(writer, "green");
                    return;
                case TracerColor.Red:
                    serializer.Serialize(writer, "red");
                    return;
                case TracerColor.TracerGreen:
                    serializer.Serialize(writer, "tracerGreen");
                    return;
                case TracerColor.TracerRed:
                    serializer.Serialize(writer, "tracerRed");
                    return;
                case TracerColor.TracerYellow:
                    serializer.Serialize(writer, "tracerYellow");
                    return;
                case TracerColor.Yellow:
                    serializer.Serialize(writer, "yellow");
                    return;
            }
            throw new Exception("Cannot marshal type TracerColor");
        }

        public static readonly TracerColorConverter Converter = new TracerColorConverter();
    }

    internal class UnlootableFromSideConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(UnlootableFromSide) || t == typeof(UnlootableFromSide?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Bear":
                    return UnlootableFromSide.Bear;
                case "Savage":
                    return UnlootableFromSide.Savage;
                case "Usec":
                    return UnlootableFromSide.Usec;
            }
            throw new Exception("Cannot unmarshal type UnlootableFromSide");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (UnlootableFromSide)untypedValue;
            switch (value)
            {
                case UnlootableFromSide.Bear:
                    serializer.Serialize(writer, "Bear");
                    return;
                case UnlootableFromSide.Savage:
                    serializer.Serialize(writer, "Savage");
                    return;
                case UnlootableFromSide.Usec:
                    serializer.Serialize(writer, "Usec");
                    return;
            }
            throw new Exception("Cannot marshal type UnlootableFromSide");
        }

        public static readonly UnlootableFromSideConverter Converter = new UnlootableFromSideConverter();
    }

    internal class UnlootableFromSlotConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(UnlootableFromSlot) || t == typeof(UnlootableFromSlot?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ArmBand":
                    return UnlootableFromSlot.ArmBand;
                case "FirstPrimaryWeapon":
                    return UnlootableFromSlot.FirstPrimaryWeapon;
                case "Holster":
                    return UnlootableFromSlot.Holster;
                case "Scabbard":
                    return UnlootableFromSlot.Scabbard;
                case "SpecialSlot":
                    return UnlootableFromSlot.SpecialSlot;
            }
            throw new Exception("Cannot unmarshal type UnlootableFromSlot");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (UnlootableFromSlot)untypedValue;
            switch (value)
            {
                case UnlootableFromSlot.ArmBand:
                    serializer.Serialize(writer, "ArmBand");
                    return;
                case UnlootableFromSlot.FirstPrimaryWeapon:
                    serializer.Serialize(writer, "FirstPrimaryWeapon");
                    return;
                case UnlootableFromSlot.Holster:
                    serializer.Serialize(writer, "Holster");
                    return;
                case UnlootableFromSlot.Scabbard:
                    serializer.Serialize(writer, "Scabbard");
                    return;
                case UnlootableFromSlot.SpecialSlot:
                    serializer.Serialize(writer, "SpecialSlot");
                    return;
            }
            throw new Exception("Cannot marshal type UnlootableFromSlot");
        }

        public static readonly UnlootableFromSlotConverter Converter = new UnlootableFromSlotConverter();
    }

    internal class VisibleAmmoRangesStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(VisibleAmmoRangesString) || t == typeof(VisibleAmmoRangesString?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return VisibleAmmoRangesString.Empty;
                case "1-12":
                    return VisibleAmmoRangesString.The112;
                case "1-1;18-30":
                    return VisibleAmmoRangesString.The111830;
                case "1-1;4-4;6-6;8-8;10-10;12-12;14-14;16-16;18-18;20-20":
                    return VisibleAmmoRangesString.The11446688101012121414161618182020;
                case "1-1;4-5;8-10;13-15;18-20":
                    return VisibleAmmoRangesString.The114581013151820;
                case "1-1;4-8":
                    return VisibleAmmoRangesString.The1148;
                case "1-2":
                    return VisibleAmmoRangesString.The12;
                case "1-25":
                    return VisibleAmmoRangesString.The125;
                case "1-2;19-27":
                    return VisibleAmmoRangesString.The121927;
                case "1-3":
                    return VisibleAmmoRangesString.The13;
                case "1-4;12-20":
                    return VisibleAmmoRangesString.The141220;
            }
            throw new Exception("Cannot unmarshal type VisibleAmmoRangesString");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (VisibleAmmoRangesString)untypedValue;
            switch (value)
            {
                case VisibleAmmoRangesString.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case VisibleAmmoRangesString.The112:
                    serializer.Serialize(writer, "1-12");
                    return;
                case VisibleAmmoRangesString.The111830:
                    serializer.Serialize(writer, "1-1;18-30");
                    return;
                case VisibleAmmoRangesString.The11446688101012121414161618182020:
                    serializer.Serialize(writer, "1-1;4-4;6-6;8-8;10-10;12-12;14-14;16-16;18-18;20-20");
                    return;
                case VisibleAmmoRangesString.The114581013151820:
                    serializer.Serialize(writer, "1-1;4-5;8-10;13-15;18-20");
                    return;
                case VisibleAmmoRangesString.The1148:
                    serializer.Serialize(writer, "1-1;4-8");
                    return;
                case VisibleAmmoRangesString.The12:
                    serializer.Serialize(writer, "1-2");
                    return;
                case VisibleAmmoRangesString.The125:
                    serializer.Serialize(writer, "1-25");
                    return;
                case VisibleAmmoRangesString.The121927:
                    serializer.Serialize(writer, "1-2;19-27");
                    return;
                case VisibleAmmoRangesString.The13:
                    serializer.Serialize(writer, "1-3");
                    return;
                case VisibleAmmoRangesString.The141220:
                    serializer.Serialize(writer, "1-4;12-20");
                    return;
            }
            throw new Exception("Cannot marshal type VisibleAmmoRangesString");
        }

        public static readonly VisibleAmmoRangesStringConverter Converter = new VisibleAmmoRangesStringConverter();
    }

    internal class AmmoSfxConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AmmoSfx) || t == typeof(AmmoSfx?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "standart":
                    return AmmoSfx.Standart;
                case "tracer":
                    return AmmoSfx.Tracer;
                case "tracer_red":
                    return AmmoSfx.TracerRed;
            }
            throw new Exception("Cannot unmarshal type AmmoSfx");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AmmoSfx)untypedValue;
            switch (value)
            {
                case AmmoSfx.Standart:
                    serializer.Serialize(writer, "standart");
                    return;
                case AmmoSfx.Tracer:
                    serializer.Serialize(writer, "tracer");
                    return;
                case AmmoSfx.TracerRed:
                    serializer.Serialize(writer, "tracer_red");
                    return;
            }
            throw new Exception("Cannot marshal type AmmoSfx");
        }

        public static readonly AmmoSfxConverter Converter = new AmmoSfxConverter();
    }

    internal class AmmoTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AmmoType) || t == typeof(AmmoType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "buckshot":
                    return AmmoType.Buckshot;
                case "bullet":
                    return AmmoType.Bullet;
                case "grenade":
                    return AmmoType.Grenade;
            }
            throw new Exception("Cannot unmarshal type AmmoType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AmmoType)untypedValue;
            switch (value)
            {
                case AmmoType.Buckshot:
                    serializer.Serialize(writer, "buckshot");
                    return;
                case AmmoType.Bullet:
                    serializer.Serialize(writer, "bullet");
                    return;
                case AmmoType.Grenade:
                    serializer.Serialize(writer, "grenade");
                    return;
            }
            throw new Exception("Cannot marshal type AmmoType");
        }

        public static readonly AmmoTypeConverter Converter = new AmmoTypeConverter();
    }

    internal class DecodingChoiceConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return integerValue;
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    long l;
                    if (Int64.TryParse(stringValue, out l))
                    {
                        return l;
                    }
                    break;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value);
            return;
        }

        public static readonly DecodingChoiceConverter Converter = new DecodingChoiceConverter();
    }

    internal class ArmorZoneConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ArmorZone) || t == typeof(ArmorZone?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Chest":
                    return ArmorZone.Chest;
                case "Head":
                    return ArmorZone.Head;
                case "LeftArm":
                    return ArmorZone.LeftArm;
                case "LeftLeg":
                    return ArmorZone.LeftLeg;
                case "RightArm":
                    return ArmorZone.RightArm;
                case "RightLeg":
                    return ArmorZone.RightLeg;
                case "Stomach":
                    return ArmorZone.Stomach;
            }
            throw new Exception("Cannot unmarshal type ArmorZone");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ArmorZone)untypedValue;
            switch (value)
            {
                case ArmorZone.Chest:
                    serializer.Serialize(writer, "Chest");
                    return;
                case ArmorZone.Head:
                    serializer.Serialize(writer, "Head");
                    return;
                case ArmorZone.LeftArm:
                    serializer.Serialize(writer, "LeftArm");
                    return;
                case ArmorZone.LeftLeg:
                    serializer.Serialize(writer, "LeftLeg");
                    return;
                case ArmorZone.RightArm:
                    serializer.Serialize(writer, "RightArm");
                    return;
                case ArmorZone.RightLeg:
                    serializer.Serialize(writer, "RightLeg");
                    return;
                case ArmorZone.Stomach:
                    serializer.Serialize(writer, "Stomach");
                    return;
            }
            throw new Exception("Cannot marshal type ArmorZone");
        }

        public static readonly ArmorZoneConverter Converter = new ArmorZoneConverter();
    }

    internal class CasingSoundsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CasingSounds) || t == typeof(CasingSounds?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "127rifle":
                    return CasingSounds.The127Rifle;
                case "40mmgrenade":
                    return CasingSounds.The40Mmgrenade;
                case "50cal":
                    return CasingSounds.The50Cal;
                case "pistol_big":
                    return CasingSounds.PistolBig;
                case "pistol_small":
                    return CasingSounds.PistolSmall;
                case "rifle556":
                    return CasingSounds.Rifle556;
                case "rifle762":
                    return CasingSounds.Rifle762;
                case "shotgun_big":
                    return CasingSounds.ShotgunBig;
                case "shotgun_small":
                    return CasingSounds.ShotgunSmall;
            }
            throw new Exception("Cannot unmarshal type CasingSounds");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CasingSounds)untypedValue;
            switch (value)
            {
                case CasingSounds.The127Rifle:
                    serializer.Serialize(writer, "127rifle");
                    return;
                case CasingSounds.The40Mmgrenade:
                    serializer.Serialize(writer, "40mmgrenade");
                    return;
                case CasingSounds.The50Cal:
                    serializer.Serialize(writer, "50cal");
                    return;
                case CasingSounds.PistolBig:
                    serializer.Serialize(writer, "pistol_big");
                    return;
                case CasingSounds.PistolSmall:
                    serializer.Serialize(writer, "pistol_small");
                    return;
                case CasingSounds.Rifle556:
                    serializer.Serialize(writer, "rifle556");
                    return;
                case CasingSounds.Rifle762:
                    serializer.Serialize(writer, "rifle762");
                    return;
                case CasingSounds.ShotgunBig:
                    serializer.Serialize(writer, "shotgun_big");
                    return;
                case CasingSounds.ShotgunSmall:
                    serializer.Serialize(writer, "shotgun_small");
                    return;
            }
            throw new Exception("Cannot marshal type CasingSounds");
        }

        public static readonly CasingSoundsConverter Converter = new CasingSoundsConverter();
    }

    internal class EffectsDamageUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(EffectsDamageUnion) || t == typeof(EffectsDamageUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<EffectsDamageClass>(reader);
                    return new EffectsDamageUnion { EffectsDamageClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<object[]>(reader);
                    return new EffectsDamageUnion { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type EffectsDamageUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (EffectsDamageUnion)untypedValue;
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.EffectsDamageClass != null)
            {
                serializer.Serialize(writer, value.EffectsDamageClass);
                return;
            }
            throw new Exception("Cannot marshal type EffectsDamageUnion");
        }

        public static readonly EffectsDamageUnionConverter Converter = new EffectsDamageUnionConverter();
    }

    internal class EffectsHealthUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(EffectsHealthUnion) || t == typeof(EffectsHealthUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<PurpleEffectsHealth>(reader);
                    return new EffectsHealthUnion { PurpleEffectsHealth = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<EffectsHealthElement[]>(reader);
                    return new EffectsHealthUnion { EffectsHealthElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type EffectsHealthUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (EffectsHealthUnion)untypedValue;
            if (value.EffectsHealthElementArray != null)
            {
                serializer.Serialize(writer, value.EffectsHealthElementArray);
                return;
            }
            if (value.PurpleEffectsHealth != null)
            {
                serializer.Serialize(writer, value.PurpleEffectsHealth);
                return;
            }
            throw new Exception("Cannot marshal type EffectsHealthUnion");
        }

        public static readonly EffectsHealthUnionConverter Converter = new EffectsHealthUnionConverter();
    }

    internal class DEffectTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DEffectType) || t == typeof(DEffectType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "afterUse":
                    return DEffectType.AfterUse;
                case "duringUse":
                    return DEffectType.DuringUse;
            }
            throw new Exception("Cannot unmarshal type DEffectType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DEffectType)untypedValue;
            switch (value)
            {
                case DEffectType.AfterUse:
                    serializer.Serialize(writer, "afterUse");
                    return;
                case DEffectType.DuringUse:
                    serializer.Serialize(writer, "duringUse");
                    return;
            }
            throw new Exception("Cannot marshal type DEffectType");
        }

        public static readonly DEffectTypeConverter Converter = new DEffectTypeConverter();
    }

    internal class HeadSegmentConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(HeadSegment) || t == typeof(HeadSegment?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Ears":
                    return HeadSegment.Ears;
                case "Eyes":
                    return HeadSegment.Eyes;
                case "Jaws":
                    return HeadSegment.Jaws;
                case "LowerNape":
                    return HeadSegment.LowerNape;
                case "Nape":
                    return HeadSegment.Nape;
                case "Top":
                    return HeadSegment.Top;
            }
            throw new Exception("Cannot unmarshal type HeadSegment");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (HeadSegment)untypedValue;
            switch (value)
            {
                case HeadSegment.Ears:
                    serializer.Serialize(writer, "Ears");
                    return;
                case HeadSegment.Eyes:
                    serializer.Serialize(writer, "Eyes");
                    return;
                case HeadSegment.Jaws:
                    serializer.Serialize(writer, "Jaws");
                    return;
                case HeadSegment.LowerNape:
                    serializer.Serialize(writer, "LowerNape");
                    return;
                case HeadSegment.Nape:
                    serializer.Serialize(writer, "Nape");
                    return;
                case HeadSegment.Top:
                    serializer.Serialize(writer, "Top");
                    return;
            }
            throw new Exception("Cannot marshal type HeadSegment");
        }

        public static readonly HeadSegmentConverter Converter = new HeadSegmentConverter();
    }

    internal class MuzzleModTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(MuzzleModType) || t == typeof(MuzzleModType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "brake":
                    return MuzzleModType.Brake;
                case "conpensator":
                    return MuzzleModType.Conpensator;
                case "muzzleCombo":
                    return MuzzleModType.MuzzleCombo;
                case "pms":
                    return MuzzleModType.Pms;
                case "silencer":
                    return MuzzleModType.Silencer;
            }
            throw new Exception("Cannot unmarshal type MuzzleModType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (MuzzleModType)untypedValue;
            switch (value)
            {
                case MuzzleModType.Brake:
                    serializer.Serialize(writer, "brake");
                    return;
                case MuzzleModType.Conpensator:
                    serializer.Serialize(writer, "conpensator");
                    return;
                case MuzzleModType.MuzzleCombo:
                    serializer.Serialize(writer, "muzzleCombo");
                    return;
                case MuzzleModType.Pms:
                    serializer.Serialize(writer, "pms");
                    return;
                case MuzzleModType.Silencer:
                    serializer.Serialize(writer, "silencer");
                    return;
            }
            throw new Exception("Cannot marshal type MuzzleModType");
        }

        public static readonly MuzzleModTypeConverter Converter = new MuzzleModTypeConverter();
    }

    internal class SightModTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SightModType) || t == typeof(SightModType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "holo":
                    return SightModType.Holo;
                case "hybrid":
                    return SightModType.Hybrid;
                case "iron":
                    return SightModType.Iron;
                case "optic":
                    return SightModType.Optic;
                case "reflex":
                    return SightModType.Reflex;
            }
            throw new Exception("Cannot unmarshal type SightModType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SightModType)untypedValue;
            switch (value)
            {
                case SightModType.Holo:
                    serializer.Serialize(writer, "holo");
                    return;
                case SightModType.Hybrid:
                    serializer.Serialize(writer, "hybrid");
                    return;
                case SightModType.Iron:
                    serializer.Serialize(writer, "iron");
                    return;
                case SightModType.Optic:
                    serializer.Serialize(writer, "optic");
                    return;
                case SightModType.Reflex:
                    serializer.Serialize(writer, "reflex");
                    return;
            }
            throw new Exception("Cannot marshal type SightModType");
        }

        public static readonly SightModTypeConverter Converter = new SightModTypeConverter();
    }

    internal class WeapClassConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(WeapClass) || t == typeof(WeapClass?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "assaultCarbine":
                    return WeapClass.AssaultCarbine;
                case "assaultRifle":
                    return WeapClass.AssaultRifle;
                case "grenadeLauncher":
                    return WeapClass.GrenadeLauncher;
                case "machinegun":
                    return WeapClass.Machinegun;
                case "marksmanRifle":
                    return WeapClass.MarksmanRifle;
                case "pistol":
                    return WeapClass.Pistol;
                case "shotgun":
                    return WeapClass.Shotgun;
                case "smg":
                    return WeapClass.Smg;
                case "sniperRifle":
                    return WeapClass.SniperRifle;
                case "specialWeapon":
                    return WeapClass.SpecialWeapon;
            }
            throw new Exception("Cannot unmarshal type WeapClass");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (WeapClass)untypedValue;
            switch (value)
            {
                case WeapClass.AssaultCarbine:
                    serializer.Serialize(writer, "assaultCarbine");
                    return;
                case WeapClass.AssaultRifle:
                    serializer.Serialize(writer, "assaultRifle");
                    return;
                case WeapClass.GrenadeLauncher:
                    serializer.Serialize(writer, "grenadeLauncher");
                    return;
                case WeapClass.Machinegun:
                    serializer.Serialize(writer, "machinegun");
                    return;
                case WeapClass.MarksmanRifle:
                    serializer.Serialize(writer, "marksmanRifle");
                    return;
                case WeapClass.Pistol:
                    serializer.Serialize(writer, "pistol");
                    return;
                case WeapClass.Shotgun:
                    serializer.Serialize(writer, "shotgun");
                    return;
                case WeapClass.Smg:
                    serializer.Serialize(writer, "smg");
                    return;
                case WeapClass.SniperRifle:
                    serializer.Serialize(writer, "sniperRifle");
                    return;
                case WeapClass.SpecialWeapon:
                    serializer.Serialize(writer, "specialWeapon");
                    return;
            }
            throw new Exception("Cannot marshal type WeapClass");
        }

        public static readonly WeapClassConverter Converter = new WeapClassConverter();
    }

    internal class WeapFireTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(WeapFireType) || t == typeof(WeapFireType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "burst":
                    return WeapFireType.Burst;
                case "doubleaction":
                    return WeapFireType.Doubleaction;
                case "doublet":
                    return WeapFireType.Doublet;
                case "fullauto":
                    return WeapFireType.Fullauto;
                case "semiauto":
                    return WeapFireType.Semiauto;
                case "single":
                    return WeapFireType.Single;
            }
            throw new Exception("Cannot unmarshal type WeapFireType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (WeapFireType)untypedValue;
            switch (value)
            {
                case WeapFireType.Burst:
                    serializer.Serialize(writer, "burst");
                    return;
                case WeapFireType.Doubleaction:
                    serializer.Serialize(writer, "doubleaction");
                    return;
                case WeapFireType.Doublet:
                    serializer.Serialize(writer, "doublet");
                    return;
                case WeapFireType.Fullauto:
                    serializer.Serialize(writer, "fullauto");
                    return;
                case WeapFireType.Semiauto:
                    serializer.Serialize(writer, "semiauto");
                    return;
                case WeapFireType.Single:
                    serializer.Serialize(writer, "single");
                    return;
            }
            throw new Exception("Cannot marshal type WeapFireType");
        }

        public static readonly WeapFireTypeConverter Converter = new WeapFireTypeConverter();
    }

    internal class WeapUseTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(WeapUseType) || t == typeof(WeapUseType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "primary":
                    return WeapUseType.Primary;
                case "secondary":
                    return WeapUseType.Secondary;
            }
            throw new Exception("Cannot unmarshal type WeapUseType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (WeapUseType)untypedValue;
            switch (value)
            {
                case WeapUseType.Primary:
                    serializer.Serialize(writer, "primary");
                    return;
                case WeapUseType.Secondary:
                    serializer.Serialize(writer, "secondary");
                    return;
            }
            throw new Exception("Cannot marshal type WeapUseType");
        }

        public static readonly WeapUseTypeConverter Converter = new WeapUseTypeConverter();
    }

    internal class TypeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TypeEnum) || t == typeof(TypeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Item":
                    return TypeEnum.Item;
                case "Node":
                    return TypeEnum.Node;
            }
            throw new Exception("Cannot unmarshal type TypeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TypeEnum)untypedValue;
            switch (value)
            {
                case TypeEnum.Item:
                    serializer.Serialize(writer, "Item");
                    return;
                case TypeEnum.Node:
                    serializer.Serialize(writer, "Node");
                    return;
            }
            throw new Exception("Cannot marshal type TypeEnum");
        }

        public static readonly TypeEnumConverter Converter = new TypeEnumConverter();
    }
}
